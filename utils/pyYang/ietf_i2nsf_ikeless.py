# -*- coding: utf-8 -*-
from operator import attrgetter
from pyangbind.lib.yangtypes import RestrictedPrecisionDecimalType
from pyangbind.lib.yangtypes import RestrictedClassType
from pyangbind.lib.yangtypes import TypedListType
from pyangbind.lib.yangtypes import YANGBool
from pyangbind.lib.yangtypes import YANGListType
from pyangbind.lib.yangtypes import YANGDynClass
from pyangbind.lib.yangtypes import ReferenceType
from pyangbind.lib.base import PybindBase
from collections import OrderedDict
from decimal import Decimal
from bitarray import bitarray
import six

# PY3 support of some PY2 keywords (needs improved)
if six.PY3:
  import builtins as __builtin__
  long = int
elif six.PY2:
  import __builtin__

class yc_local_ports_ietf_i2nsf_ikeless__ipsec_ikeless_spd_spd_entry_ipsec_policy_config_traffic_selector_local_ports(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-i2nsf-ikeless - based on the path /ipsec-ikeless/spd/spd-entry/ipsec-policy-config/traffic-selector/local-ports. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of local ports. When the inner
protocol is ICMP, this 16-bit value
represents code and type.
If this list is not defined,
it is assumed that start and
end are 0 by default (any port).
  """
  __slots__ = ('_path_helper', '_extmethods', '__start','__end',)

  _yang_name = 'local-ports'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__start = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..65535']}), is_leaf=True, yang_name="start", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='inet:port-number', is_config=True)
    self.__end = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..65535']}), is_leaf=True, yang_name="end", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='inet:port-number', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['ipsec-ikeless', 'spd', 'spd-entry', 'ipsec-policy-config', 'traffic-selector', 'local-ports']

  def _get_start(self):
    """
    Getter method for start, mapped from YANG variable /ipsec_ikeless/spd/spd_entry/ipsec_policy_config/traffic_selector/local_ports/start (inet:port-number)

    YANG Description: Start port number.
    """
    return self.__start
      
  def _set_start(self, v, load=False):
    """
    Setter method for start, mapped from YANG variable /ipsec_ikeless/spd/spd_entry/ipsec_policy_config/traffic_selector/local_ports/start (inet:port-number)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_start is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_start() directly.

    YANG Description: Start port number.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..65535']}), is_leaf=True, yang_name="start", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='inet:port-number', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """start must be of a type compatible with inet:port-number""",
          'defined-type': "inet:port-number",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..65535']}), is_leaf=True, yang_name="start", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='inet:port-number', is_config=True)""",
        })

    self.__start = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_start(self):
    self.__start = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..65535']}), is_leaf=True, yang_name="start", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='inet:port-number', is_config=True)


  def _get_end(self):
    """
    Getter method for end, mapped from YANG variable /ipsec_ikeless/spd/spd_entry/ipsec_policy_config/traffic_selector/local_ports/end (inet:port-number)

    YANG Description: End port number.  To express a single port, set
the same value as start and end.
    """
    return self.__end
      
  def _set_end(self, v, load=False):
    """
    Setter method for end, mapped from YANG variable /ipsec_ikeless/spd/spd_entry/ipsec_policy_config/traffic_selector/local_ports/end (inet:port-number)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_end is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_end() directly.

    YANG Description: End port number.  To express a single port, set
the same value as start and end.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..65535']}), is_leaf=True, yang_name="end", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='inet:port-number', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """end must be of a type compatible with inet:port-number""",
          'defined-type': "inet:port-number",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..65535']}), is_leaf=True, yang_name="end", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='inet:port-number', is_config=True)""",
        })

    self.__end = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_end(self):
    self.__end = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..65535']}), is_leaf=True, yang_name="end", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='inet:port-number', is_config=True)

  start = __builtin__.property(_get_start, _set_start)
  end = __builtin__.property(_get_end, _set_end)


  _pyangbind_elements = OrderedDict([('start', start), ('end', end), ])


class yc_remote_ports_ietf_i2nsf_ikeless__ipsec_ikeless_spd_spd_entry_ipsec_policy_config_traffic_selector_remote_ports(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-i2nsf-ikeless - based on the path /ipsec-ikeless/spd/spd-entry/ipsec-policy-config/traffic-selector/remote-ports. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of remote ports. When the upper layer
protocol is ICMP, this 16-bit value represents
code and type.  If this list is not defined,
it is assumed that start and end are 0 by
default (any port).
  """
  __slots__ = ('_path_helper', '_extmethods', '__start','__end',)

  _yang_name = 'remote-ports'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__start = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..65535']}), is_leaf=True, yang_name="start", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='inet:port-number', is_config=True)
    self.__end = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..65535']}), is_leaf=True, yang_name="end", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='inet:port-number', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['ipsec-ikeless', 'spd', 'spd-entry', 'ipsec-policy-config', 'traffic-selector', 'remote-ports']

  def _get_start(self):
    """
    Getter method for start, mapped from YANG variable /ipsec_ikeless/spd/spd_entry/ipsec_policy_config/traffic_selector/remote_ports/start (inet:port-number)

    YANG Description: Start port number.
    """
    return self.__start
      
  def _set_start(self, v, load=False):
    """
    Setter method for start, mapped from YANG variable /ipsec_ikeless/spd/spd_entry/ipsec_policy_config/traffic_selector/remote_ports/start (inet:port-number)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_start is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_start() directly.

    YANG Description: Start port number.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..65535']}), is_leaf=True, yang_name="start", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='inet:port-number', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """start must be of a type compatible with inet:port-number""",
          'defined-type': "inet:port-number",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..65535']}), is_leaf=True, yang_name="start", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='inet:port-number', is_config=True)""",
        })

    self.__start = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_start(self):
    self.__start = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..65535']}), is_leaf=True, yang_name="start", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='inet:port-number', is_config=True)


  def _get_end(self):
    """
    Getter method for end, mapped from YANG variable /ipsec_ikeless/spd/spd_entry/ipsec_policy_config/traffic_selector/remote_ports/end (inet:port-number)

    YANG Description: End port number.  To express a single port, set
the same value as start and end.
    """
    return self.__end
      
  def _set_end(self, v, load=False):
    """
    Setter method for end, mapped from YANG variable /ipsec_ikeless/spd/spd_entry/ipsec_policy_config/traffic_selector/remote_ports/end (inet:port-number)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_end is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_end() directly.

    YANG Description: End port number.  To express a single port, set
the same value as start and end.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..65535']}), is_leaf=True, yang_name="end", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='inet:port-number', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """end must be of a type compatible with inet:port-number""",
          'defined-type': "inet:port-number",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..65535']}), is_leaf=True, yang_name="end", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='inet:port-number', is_config=True)""",
        })

    self.__end = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_end(self):
    self.__end = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..65535']}), is_leaf=True, yang_name="end", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='inet:port-number', is_config=True)

  start = __builtin__.property(_get_start, _set_start)
  end = __builtin__.property(_get_end, _set_end)


  _pyangbind_elements = OrderedDict([('start', start), ('end', end), ])


class yc_traffic_selector_ietf_i2nsf_ikeless__ipsec_ikeless_spd_spd_entry_ipsec_policy_config_traffic_selector(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-i2nsf-ikeless - based on the path /ipsec-ikeless/spd/spd-entry/ipsec-policy-config/traffic-selector. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Packets are selected for
processing actions based on Traffic Selector
values, which refer to IP and inner protocol
header information.
  """
  __slots__ = ('_path_helper', '_extmethods', '__local_prefix','__remote_prefix','__inner_protocol','__local_ports','__remote_ports',)

  _yang_name = 'traffic-selector'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__local_prefix = YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])/(([0-9])|([1-2][0-9])|(3[0-2]))'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(/(([0-9])|([0-9]{2})|(1[0-1][0-9])|(12[0-8])))'}),], is_leaf=True, yang_name="local-prefix", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='inet:ip-prefix', is_config=True)
    self.__remote_prefix = YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])/(([0-9])|([1-2][0-9])|(3[0-2]))'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(/(([0-9])|([0-9]{2})|(1[0-1][0-9])|(12[0-8])))'}),], is_leaf=True, yang_name="remote-prefix", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='inet:ip-prefix', is_config=True)
    self.__inner_protocol = YANGDynClass(base=[RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8),RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'any': {'value': 256}},),], default=six.text_type("a"), is_leaf=True, yang_name="inner-protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='ipsec-inner-protocol', is_config=True)
    self.__local_ports = YANGDynClass(base=YANGListType("start end",yc_local_ports_ietf_i2nsf_ikeless__ipsec_ikeless_spd_spd_entry_ipsec_policy_config_traffic_selector_local_ports, yang_name="local-ports", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='start end', extensions=None), is_container='list', yang_name="local-ports", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='list', is_config=True)
    self.__remote_ports = YANGDynClass(base=YANGListType("start end",yc_remote_ports_ietf_i2nsf_ikeless__ipsec_ikeless_spd_spd_entry_ipsec_policy_config_traffic_selector_remote_ports, yang_name="remote-ports", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='start end', extensions=None), is_container='list', yang_name="remote-ports", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['ipsec-ikeless', 'spd', 'spd-entry', 'ipsec-policy-config', 'traffic-selector']

  def _get_local_prefix(self):
    """
    Getter method for local_prefix, mapped from YANG variable /ipsec_ikeless/spd/spd_entry/ipsec_policy_config/traffic_selector/local_prefix (inet:ip-prefix)

    YANG Description: Local IP address prefix.
    """
    return self.__local_prefix
      
  def _set_local_prefix(self, v, load=False):
    """
    Setter method for local_prefix, mapped from YANG variable /ipsec_ikeless/spd/spd_entry/ipsec_policy_config/traffic_selector/local_prefix (inet:ip-prefix)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_local_prefix is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_local_prefix() directly.

    YANG Description: Local IP address prefix.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])/(([0-9])|([1-2][0-9])|(3[0-2]))'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(/(([0-9])|([0-9]{2})|(1[0-1][0-9])|(12[0-8])))'}),], is_leaf=True, yang_name="local-prefix", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='inet:ip-prefix', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """local_prefix must be of a type compatible with inet:ip-prefix""",
          'defined-type': "inet:ip-prefix",
          'generated-type': """YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])/(([0-9])|([1-2][0-9])|(3[0-2]))'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(/(([0-9])|([0-9]{2})|(1[0-1][0-9])|(12[0-8])))'}),], is_leaf=True, yang_name="local-prefix", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='inet:ip-prefix', is_config=True)""",
        })

    self.__local_prefix = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_local_prefix(self):
    self.__local_prefix = YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])/(([0-9])|([1-2][0-9])|(3[0-2]))'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(/(([0-9])|([0-9]{2})|(1[0-1][0-9])|(12[0-8])))'}),], is_leaf=True, yang_name="local-prefix", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='inet:ip-prefix', is_config=True)


  def _get_remote_prefix(self):
    """
    Getter method for remote_prefix, mapped from YANG variable /ipsec_ikeless/spd/spd_entry/ipsec_policy_config/traffic_selector/remote_prefix (inet:ip-prefix)

    YANG Description: Remote IP address prefix.
    """
    return self.__remote_prefix
      
  def _set_remote_prefix(self, v, load=False):
    """
    Setter method for remote_prefix, mapped from YANG variable /ipsec_ikeless/spd/spd_entry/ipsec_policy_config/traffic_selector/remote_prefix (inet:ip-prefix)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_remote_prefix is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_remote_prefix() directly.

    YANG Description: Remote IP address prefix.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])/(([0-9])|([1-2][0-9])|(3[0-2]))'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(/(([0-9])|([0-9]{2})|(1[0-1][0-9])|(12[0-8])))'}),], is_leaf=True, yang_name="remote-prefix", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='inet:ip-prefix', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """remote_prefix must be of a type compatible with inet:ip-prefix""",
          'defined-type': "inet:ip-prefix",
          'generated-type': """YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])/(([0-9])|([1-2][0-9])|(3[0-2]))'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(/(([0-9])|([0-9]{2})|(1[0-1][0-9])|(12[0-8])))'}),], is_leaf=True, yang_name="remote-prefix", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='inet:ip-prefix', is_config=True)""",
        })

    self.__remote_prefix = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_remote_prefix(self):
    self.__remote_prefix = YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])/(([0-9])|([1-2][0-9])|(3[0-2]))'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(/(([0-9])|([0-9]{2})|(1[0-1][0-9])|(12[0-8])))'}),], is_leaf=True, yang_name="remote-prefix", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='inet:ip-prefix', is_config=True)


  def _get_inner_protocol(self):
    """
    Getter method for inner_protocol, mapped from YANG variable /ipsec_ikeless/spd/spd_entry/ipsec_policy_config/traffic_selector/inner_protocol (ipsec-inner-protocol)

    YANG Description: Inner protocol that is going to be
protected with IPsec.
    """
    return self.__inner_protocol
      
  def _set_inner_protocol(self, v, load=False):
    """
    Setter method for inner_protocol, mapped from YANG variable /ipsec_ikeless/spd/spd_entry/ipsec_policy_config/traffic_selector/inner_protocol (ipsec-inner-protocol)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_inner_protocol is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_inner_protocol() directly.

    YANG Description: Inner protocol that is going to be
protected with IPsec.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=[RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8),RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'any': {'value': 256}},),], default=six.text_type("a"), is_leaf=True, yang_name="inner-protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='ipsec-inner-protocol', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """inner_protocol must be of a type compatible with ipsec-inner-protocol""",
          'defined-type': "ietf-i2nsf-ikeless:ipsec-inner-protocol",
          'generated-type': """YANGDynClass(base=[RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8),RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'any': {'value': 256}},),], default=six.text_type("a"), is_leaf=True, yang_name="inner-protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='ipsec-inner-protocol', is_config=True)""",
        })

    self.__inner_protocol = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_inner_protocol(self):
    self.__inner_protocol = YANGDynClass(base=[RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8),RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'any': {'value': 256}},),], default=six.text_type("a"), is_leaf=True, yang_name="inner-protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='ipsec-inner-protocol', is_config=True)


  def _get_local_ports(self):
    """
    Getter method for local_ports, mapped from YANG variable /ipsec_ikeless/spd/spd_entry/ipsec_policy_config/traffic_selector/local_ports (list)

    YANG Description: List of local ports. When the inner
protocol is ICMP, this 16-bit value
represents code and type.
If this list is not defined,
it is assumed that start and
end are 0 by default (any port).
    """
    return self.__local_ports
      
  def _set_local_ports(self, v, load=False):
    """
    Setter method for local_ports, mapped from YANG variable /ipsec_ikeless/spd/spd_entry/ipsec_policy_config/traffic_selector/local_ports (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_local_ports is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_local_ports() directly.

    YANG Description: List of local ports. When the inner
protocol is ICMP, this 16-bit value
represents code and type.
If this list is not defined,
it is assumed that start and
end are 0 by default (any port).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("start end",yc_local_ports_ietf_i2nsf_ikeless__ipsec_ikeless_spd_spd_entry_ipsec_policy_config_traffic_selector_local_ports, yang_name="local-ports", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='start end', extensions=None), is_container='list', yang_name="local-ports", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """local_ports must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("start end",yc_local_ports_ietf_i2nsf_ikeless__ipsec_ikeless_spd_spd_entry_ipsec_policy_config_traffic_selector_local_ports, yang_name="local-ports", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='start end', extensions=None), is_container='list', yang_name="local-ports", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='list', is_config=True)""",
        })

    self.__local_ports = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_local_ports(self):
    self.__local_ports = YANGDynClass(base=YANGListType("start end",yc_local_ports_ietf_i2nsf_ikeless__ipsec_ikeless_spd_spd_entry_ipsec_policy_config_traffic_selector_local_ports, yang_name="local-ports", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='start end', extensions=None), is_container='list', yang_name="local-ports", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='list', is_config=True)


  def _get_remote_ports(self):
    """
    Getter method for remote_ports, mapped from YANG variable /ipsec_ikeless/spd/spd_entry/ipsec_policy_config/traffic_selector/remote_ports (list)

    YANG Description: List of remote ports. When the upper layer
protocol is ICMP, this 16-bit value represents
code and type.  If this list is not defined,
it is assumed that start and end are 0 by
default (any port).
    """
    return self.__remote_ports
      
  def _set_remote_ports(self, v, load=False):
    """
    Setter method for remote_ports, mapped from YANG variable /ipsec_ikeless/spd/spd_entry/ipsec_policy_config/traffic_selector/remote_ports (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_remote_ports is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_remote_ports() directly.

    YANG Description: List of remote ports. When the upper layer
protocol is ICMP, this 16-bit value represents
code and type.  If this list is not defined,
it is assumed that start and end are 0 by
default (any port).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("start end",yc_remote_ports_ietf_i2nsf_ikeless__ipsec_ikeless_spd_spd_entry_ipsec_policy_config_traffic_selector_remote_ports, yang_name="remote-ports", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='start end', extensions=None), is_container='list', yang_name="remote-ports", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """remote_ports must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("start end",yc_remote_ports_ietf_i2nsf_ikeless__ipsec_ikeless_spd_spd_entry_ipsec_policy_config_traffic_selector_remote_ports, yang_name="remote-ports", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='start end', extensions=None), is_container='list', yang_name="remote-ports", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='list', is_config=True)""",
        })

    self.__remote_ports = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_remote_ports(self):
    self.__remote_ports = YANGDynClass(base=YANGListType("start end",yc_remote_ports_ietf_i2nsf_ikeless__ipsec_ikeless_spd_spd_entry_ipsec_policy_config_traffic_selector_remote_ports, yang_name="remote-ports", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='start end', extensions=None), is_container='list', yang_name="remote-ports", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='list', is_config=True)

  local_prefix = __builtin__.property(_get_local_prefix, _set_local_prefix)
  remote_prefix = __builtin__.property(_get_remote_prefix, _set_remote_prefix)
  inner_protocol = __builtin__.property(_get_inner_protocol, _set_inner_protocol)
  local_ports = __builtin__.property(_get_local_ports, _set_local_ports)
  remote_ports = __builtin__.property(_get_remote_ports, _set_remote_ports)


  _pyangbind_elements = OrderedDict([('local_prefix', local_prefix), ('remote_prefix', remote_prefix), ('inner_protocol', inner_protocol), ('local_ports', local_ports), ('remote_ports', remote_ports), ])


class yc_encryption_ietf_i2nsf_ikeless__ipsec_ikeless_spd_spd_entry_ipsec_policy_config_processing_info_ipsec_sa_cfg_esp_algorithms_encryption(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-i2nsf-ikeless - based on the path /ipsec-ikeless/spd/spd-entry/ipsec-policy-config/processing-info/ipsec-sa-cfg/esp-algorithms/encryption. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Encryption or AEAD algorithm for the
IPsec SAs.  This list is ordered
following from the higher priority to
lower priority.  First node of the
list will be the algorithm with
higher priority.  In case the list
is empty, then no encryption algorithm
is applied (NULL).
  """
  __slots__ = ('_path_helper', '_extmethods', '__id','__algorithm_type','__key_length',)

  _yang_name = 'encryption'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__id = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='uint16', is_config=True)
    self.__algorithm_type = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(20), is_leaf=True, yang_name="algorithm-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='encr-alg-t', is_config=True)
    self.__key_length = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(128), is_leaf=True, yang_name="key-length", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='uint16', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['ipsec-ikeless', 'spd', 'spd-entry', 'ipsec-policy-config', 'processing-info', 'ipsec-sa-cfg', 'esp-algorithms', 'encryption']

  def _get_id(self):
    """
    Getter method for id, mapped from YANG variable /ipsec_ikeless/spd/spd_entry/ipsec_policy_config/processing_info/ipsec_sa_cfg/esp_algorithms/encryption/id (uint16)

    YANG Description: An identifier that unequivocally identifies each
entry of the list, i.e., an encryption algorithm
and its key length (if required).
    """
    return self.__id
      
  def _set_id(self, v, load=False):
    """
    Setter method for id, mapped from YANG variable /ipsec_ikeless/spd/spd_entry/ipsec_policy_config/processing_info/ipsec_sa_cfg/esp_algorithms/encryption/id (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.

    YANG Description: An identifier that unequivocally identifies each
entry of the list, i.e., an encryption algorithm
and its key length (if required).
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='uint16', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """id must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='uint16', is_config=True)""",
        })

    self.__id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_id(self):
    self.__id = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='uint16', is_config=True)


  def _get_algorithm_type(self):
    """
    Getter method for algorithm_type, mapped from YANG variable /ipsec_ikeless/spd/spd_entry/ipsec_policy_config/processing_info/ipsec_sa_cfg/esp_algorithms/encryption/algorithm_type (encr-alg-t)

    YANG Description: Default value 20 (ENCR_AES_GCM_16).
    """
    return self.__algorithm_type
      
  def _set_algorithm_type(self, v, load=False):
    """
    Setter method for algorithm_type, mapped from YANG variable /ipsec_ikeless/spd/spd_entry/ipsec_policy_config/processing_info/ipsec_sa_cfg/esp_algorithms/encryption/algorithm_type (encr-alg-t)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_algorithm_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_algorithm_type() directly.

    YANG Description: Default value 20 (ENCR_AES_GCM_16).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(20), is_leaf=True, yang_name="algorithm-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='encr-alg-t', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """algorithm_type must be of a type compatible with encr-alg-t""",
          'defined-type': "ietf-i2nsf-ikeless:encr-alg-t",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(20), is_leaf=True, yang_name="algorithm-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='encr-alg-t', is_config=True)""",
        })

    self.__algorithm_type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_algorithm_type(self):
    self.__algorithm_type = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(20), is_leaf=True, yang_name="algorithm-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='encr-alg-t', is_config=True)


  def _get_key_length(self):
    """
    Getter method for key_length, mapped from YANG variable /ipsec_ikeless/spd/spd_entry/ipsec_policy_config/processing_info/ipsec_sa_cfg/esp_algorithms/encryption/key_length (uint16)

    YANG Description: By default, key length is 128
bits.
    """
    return self.__key_length
      
  def _set_key_length(self, v, load=False):
    """
    Setter method for key_length, mapped from YANG variable /ipsec_ikeless/spd/spd_entry/ipsec_policy_config/processing_info/ipsec_sa_cfg/esp_algorithms/encryption/key_length (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_key_length is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_key_length() directly.

    YANG Description: By default, key length is 128
bits.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(128), is_leaf=True, yang_name="key-length", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='uint16', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """key_length must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(128), is_leaf=True, yang_name="key-length", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='uint16', is_config=True)""",
        })

    self.__key_length = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_key_length(self):
    self.__key_length = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(128), is_leaf=True, yang_name="key-length", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='uint16', is_config=True)

  id = __builtin__.property(_get_id, _set_id)
  algorithm_type = __builtin__.property(_get_algorithm_type, _set_algorithm_type)
  key_length = __builtin__.property(_get_key_length, _set_key_length)


  _pyangbind_elements = OrderedDict([('id', id), ('algorithm_type', algorithm_type), ('key_length', key_length), ])


class yc_esp_algorithms_ietf_i2nsf_ikeless__ipsec_ikeless_spd_spd_entry_ipsec_policy_config_processing_info_ipsec_sa_cfg_esp_algorithms(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-i2nsf-ikeless - based on the path /ipsec-ikeless/spd/spd-entry/ipsec-policy-config/processing-info/ipsec-sa-cfg/esp-algorithms. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configuration of Encapsulating
Security Payload (ESP) parameters and
algorithms.
  """
  __slots__ = ('_path_helper', '_extmethods', '__integrity','__encryption','__tfc_pad',)

  _yang_name = 'esp-algorithms'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__integrity = YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(0), is_leaf=False, yang_name="integrity", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='intr-alg-t', is_config=True)
    self.__encryption = YANGDynClass(base=YANGListType("id",yc_encryption_ietf_i2nsf_ikeless__ipsec_ikeless_spd_spd_entry_ipsec_policy_config_processing_info_ipsec_sa_cfg_esp_algorithms_encryption, yang_name="encryption", parent=self, is_container='list', user_ordered=True, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="encryption", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='list', is_config=True)
    self.__tfc_pad = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="tfc-pad", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='boolean', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['ipsec-ikeless', 'spd', 'spd-entry', 'ipsec-policy-config', 'processing-info', 'ipsec-sa-cfg', 'esp-algorithms']

  def _get_integrity(self):
    """
    Getter method for integrity, mapped from YANG variable /ipsec_ikeless/spd/spd_entry/ipsec_policy_config/processing_info/ipsec_sa_cfg/esp_algorithms/integrity (intr-alg-t)

    YANG Description: Configuration of ESP authentication
based on the specified integrity
algorithm.  With AEAD encryption
algorithms, the integrity node is
not used.
    """
    return self.__integrity
      
  def _set_integrity(self, v, load=False):
    """
    Setter method for integrity, mapped from YANG variable /ipsec_ikeless/spd/spd_entry/ipsec_policy_config/processing_info/ipsec_sa_cfg/esp_algorithms/integrity (intr-alg-t)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_integrity is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_integrity() directly.

    YANG Description: Configuration of ESP authentication
based on the specified integrity
algorithm.  With AEAD encryption
algorithms, the integrity node is
not used.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(0), is_leaf=False, yang_name="integrity", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='intr-alg-t', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """integrity must be of a type compatible with intr-alg-t""",
          'defined-type': "ietf-i2nsf-ikeless:intr-alg-t",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(0), is_leaf=False, yang_name="integrity", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='intr-alg-t', is_config=True)""",
        })

    self.__integrity = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_integrity(self):
    self.__integrity = YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(0), is_leaf=False, yang_name="integrity", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='intr-alg-t', is_config=True)


  def _get_encryption(self):
    """
    Getter method for encryption, mapped from YANG variable /ipsec_ikeless/spd/spd_entry/ipsec_policy_config/processing_info/ipsec_sa_cfg/esp_algorithms/encryption (list)

    YANG Description: Encryption or AEAD algorithm for the
IPsec SAs.  This list is ordered
following from the higher priority to
lower priority.  First node of the
list will be the algorithm with
higher priority.  In case the list
is empty, then no encryption algorithm
is applied (NULL).
    """
    return self.__encryption
      
  def _set_encryption(self, v, load=False):
    """
    Setter method for encryption, mapped from YANG variable /ipsec_ikeless/spd/spd_entry/ipsec_policy_config/processing_info/ipsec_sa_cfg/esp_algorithms/encryption (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_encryption is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_encryption() directly.

    YANG Description: Encryption or AEAD algorithm for the
IPsec SAs.  This list is ordered
following from the higher priority to
lower priority.  First node of the
list will be the algorithm with
higher priority.  In case the list
is empty, then no encryption algorithm
is applied (NULL).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("id",yc_encryption_ietf_i2nsf_ikeless__ipsec_ikeless_spd_spd_entry_ipsec_policy_config_processing_info_ipsec_sa_cfg_esp_algorithms_encryption, yang_name="encryption", parent=self, is_container='list', user_ordered=True, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="encryption", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """encryption must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("id",yc_encryption_ietf_i2nsf_ikeless__ipsec_ikeless_spd_spd_entry_ipsec_policy_config_processing_info_ipsec_sa_cfg_esp_algorithms_encryption, yang_name="encryption", parent=self, is_container='list', user_ordered=True, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="encryption", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='list', is_config=True)""",
        })

    self.__encryption = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_encryption(self):
    self.__encryption = YANGDynClass(base=YANGListType("id",yc_encryption_ietf_i2nsf_ikeless__ipsec_ikeless_spd_spd_entry_ipsec_policy_config_processing_info_ipsec_sa_cfg_esp_algorithms_encryption, yang_name="encryption", parent=self, is_container='list', user_ordered=True, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="encryption", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='list', is_config=True)


  def _get_tfc_pad(self):
    """
    Getter method for tfc_pad, mapped from YANG variable /ipsec_ikeless/spd/spd_entry/ipsec_policy_config/processing_info/ipsec_sa_cfg/esp_algorithms/tfc_pad (boolean)

    YANG Description: If Traffic Flow Confidentiality
(TFC) padding for ESP encryption
can be used (true) or not (false).
    """
    return self.__tfc_pad
      
  def _set_tfc_pad(self, v, load=False):
    """
    Setter method for tfc_pad, mapped from YANG variable /ipsec_ikeless/spd/spd_entry/ipsec_policy_config/processing_info/ipsec_sa_cfg/esp_algorithms/tfc_pad (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_tfc_pad is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_tfc_pad() directly.

    YANG Description: If Traffic Flow Confidentiality
(TFC) padding for ESP encryption
can be used (true) or not (false).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="tfc-pad", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """tfc_pad must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="tfc-pad", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='boolean', is_config=True)""",
        })

    self.__tfc_pad = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_tfc_pad(self):
    self.__tfc_pad = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="tfc-pad", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='boolean', is_config=True)

  integrity = __builtin__.property(_get_integrity, _set_integrity)
  encryption = __builtin__.property(_get_encryption, _set_encryption)
  tfc_pad = __builtin__.property(_get_tfc_pad, _set_tfc_pad)


  _pyangbind_elements = OrderedDict([('integrity', integrity), ('encryption', encryption), ('tfc_pad', tfc_pad), ])


class yc_dscp_mapping_ietf_i2nsf_ikeless__ipsec_ikeless_spd_spd_entry_ipsec_policy_config_processing_info_ipsec_sa_cfg_tunnel_dscp_mapping(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-i2nsf-ikeless - based on the path /ipsec-ikeless/spd/spd-entry/ipsec-policy-config/processing-info/ipsec-sa-cfg/tunnel/dscp-mapping. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: A list that represents an array with the mapping from the
inner DSCP value to outer DSCP value when bypass-dscp is
false.  To express a default mapping in the list where any
other inner dscp value is not matching a node in the list,
a new node has to be included at the end of the list where
the leaf inner-dscp is not defined (ANY) and the leaf
outer-dscp includes the value of the mapping.  If there is
no value set in the leaf outer-dscp, the default value for
this leaf is 0.
  """
  __slots__ = ('_path_helper', '_extmethods', '__id','__inner_dscp','__outer_dscp',)

  _yang_name = 'dscp-mapping'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__id = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='uint8', is_config=True)
    self.__inner_dscp = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..63']}), is_leaf=True, yang_name="inner-dscp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='inet:dscp', is_config=True)
    self.__outer_dscp = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..63']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)(0), is_leaf=True, yang_name="outer-dscp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='inet:dscp', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['ipsec-ikeless', 'spd', 'spd-entry', 'ipsec-policy-config', 'processing-info', 'ipsec-sa-cfg', 'tunnel', 'dscp-mapping']

  def _get_id(self):
    """
    Getter method for id, mapped from YANG variable /ipsec_ikeless/spd/spd_entry/ipsec_policy_config/processing_info/ipsec_sa_cfg/tunnel/dscp_mapping/id (uint8)

    YANG Description: The index of list with the
different mappings.
    """
    return self.__id
      
  def _set_id(self, v, load=False):
    """
    Setter method for id, mapped from YANG variable /ipsec_ikeless/spd/spd_entry/ipsec_policy_config/processing_info/ipsec_sa_cfg/tunnel/dscp_mapping/id (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.

    YANG Description: The index of list with the
different mappings.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='uint8', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """id must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='uint8', is_config=True)""",
        })

    self.__id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_id(self):
    self.__id = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='uint8', is_config=True)


  def _get_inner_dscp(self):
    """
    Getter method for inner_dscp, mapped from YANG variable /ipsec_ikeless/spd/spd_entry/ipsec_policy_config/processing_info/ipsec_sa_cfg/tunnel/dscp_mapping/inner_dscp (inet:dscp)

    YANG Description: The DSCP value of the inner IP packet.  If this
leaf is not defined, it means ANY inner DSCP value.
    """
    return self.__inner_dscp
      
  def _set_inner_dscp(self, v, load=False):
    """
    Setter method for inner_dscp, mapped from YANG variable /ipsec_ikeless/spd/spd_entry/ipsec_policy_config/processing_info/ipsec_sa_cfg/tunnel/dscp_mapping/inner_dscp (inet:dscp)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_inner_dscp is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_inner_dscp() directly.

    YANG Description: The DSCP value of the inner IP packet.  If this
leaf is not defined, it means ANY inner DSCP value.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..63']}), is_leaf=True, yang_name="inner-dscp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='inet:dscp', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """inner_dscp must be of a type compatible with inet:dscp""",
          'defined-type': "inet:dscp",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..63']}), is_leaf=True, yang_name="inner-dscp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='inet:dscp', is_config=True)""",
        })

    self.__inner_dscp = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_inner_dscp(self):
    self.__inner_dscp = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..63']}), is_leaf=True, yang_name="inner-dscp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='inet:dscp', is_config=True)


  def _get_outer_dscp(self):
    """
    Getter method for outer_dscp, mapped from YANG variable /ipsec_ikeless/spd/spd_entry/ipsec_policy_config/processing_info/ipsec_sa_cfg/tunnel/dscp_mapping/outer_dscp (inet:dscp)

    YANG Description: The DSCP value of the outer IP packet.
    """
    return self.__outer_dscp
      
  def _set_outer_dscp(self, v, load=False):
    """
    Setter method for outer_dscp, mapped from YANG variable /ipsec_ikeless/spd/spd_entry/ipsec_policy_config/processing_info/ipsec_sa_cfg/tunnel/dscp_mapping/outer_dscp (inet:dscp)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_outer_dscp is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_outer_dscp() directly.

    YANG Description: The DSCP value of the outer IP packet.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..63']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)(0), is_leaf=True, yang_name="outer-dscp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='inet:dscp', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """outer_dscp must be of a type compatible with inet:dscp""",
          'defined-type': "inet:dscp",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..63']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)(0), is_leaf=True, yang_name="outer-dscp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='inet:dscp', is_config=True)""",
        })

    self.__outer_dscp = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_outer_dscp(self):
    self.__outer_dscp = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..63']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)(0), is_leaf=True, yang_name="outer-dscp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='inet:dscp', is_config=True)

  id = __builtin__.property(_get_id, _set_id)
  inner_dscp = __builtin__.property(_get_inner_dscp, _set_inner_dscp)
  outer_dscp = __builtin__.property(_get_outer_dscp, _set_outer_dscp)


  _pyangbind_elements = OrderedDict([('id', id), ('inner_dscp', inner_dscp), ('outer_dscp', outer_dscp), ])


class yc_tunnel_ietf_i2nsf_ikeless__ipsec_ikeless_spd_spd_entry_ipsec_policy_config_processing_info_ipsec_sa_cfg_tunnel(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-i2nsf-ikeless - based on the path /ipsec-ikeless/spd/spd-entry/ipsec-policy-config/processing-info/ipsec-sa-cfg/tunnel. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: IPsec tunnel endpoints definition.
  """
  __slots__ = ('_path_helper', '_extmethods', '__local_','__remote','__df_bit','__bypass_dscp','__dscp_mapping',)

  _yang_name = 'tunnel'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__local_ = YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="local", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='inet:ip-address', is_config=True)
    self.__remote = YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="remote", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='inet:ip-address', is_config=True)
    self.__df_bit = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'clear': {}, 'set': {}, 'copy': {}},), default=six.text_type("clear"), is_leaf=True, yang_name="df-bit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='enumeration', is_config=True)
    self.__bypass_dscp = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="bypass-dscp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='boolean', is_config=True)
    self.__dscp_mapping = YANGDynClass(base=YANGListType("id",yc_dscp_mapping_ietf_i2nsf_ikeless__ipsec_ikeless_spd_spd_entry_ipsec_policy_config_processing_info_ipsec_sa_cfg_tunnel_dscp_mapping, yang_name="dscp-mapping", parent=self, is_container='list', user_ordered=True, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="dscp-mapping", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['ipsec-ikeless', 'spd', 'spd-entry', 'ipsec-policy-config', 'processing-info', 'ipsec-sa-cfg', 'tunnel']

  def _get_local_(self):
    """
    Getter method for local_, mapped from YANG variable /ipsec_ikeless/spd/spd_entry/ipsec_policy_config/processing_info/ipsec_sa_cfg/tunnel/local (inet:ip-address)

    YANG Description: Local IP address' tunnel endpoint.
    """
    return self.__local_
      
  def _set_local_(self, v, load=False):
    """
    Setter method for local_, mapped from YANG variable /ipsec_ikeless/spd/spd_entry/ipsec_policy_config/processing_info/ipsec_sa_cfg/tunnel/local (inet:ip-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_local_ is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_local_() directly.

    YANG Description: Local IP address' tunnel endpoint.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="local", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='inet:ip-address', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """local_ must be of a type compatible with inet:ip-address""",
          'defined-type': "inet:ip-address",
          'generated-type': """YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="local", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='inet:ip-address', is_config=True)""",
        })

    self.__local_ = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_local_(self):
    self.__local_ = YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="local", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='inet:ip-address', is_config=True)


  def _get_remote(self):
    """
    Getter method for remote, mapped from YANG variable /ipsec_ikeless/spd/spd_entry/ipsec_policy_config/processing_info/ipsec_sa_cfg/tunnel/remote (inet:ip-address)

    YANG Description: Remote IP address' tunnel endpoint.
    """
    return self.__remote
      
  def _set_remote(self, v, load=False):
    """
    Setter method for remote, mapped from YANG variable /ipsec_ikeless/spd/spd_entry/ipsec_policy_config/processing_info/ipsec_sa_cfg/tunnel/remote (inet:ip-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_remote is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_remote() directly.

    YANG Description: Remote IP address' tunnel endpoint.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="remote", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='inet:ip-address', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """remote must be of a type compatible with inet:ip-address""",
          'defined-type': "inet:ip-address",
          'generated-type': """YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="remote", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='inet:ip-address', is_config=True)""",
        })

    self.__remote = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_remote(self):
    self.__remote = YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="remote", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='inet:ip-address', is_config=True)


  def _get_df_bit(self):
    """
    Getter method for df_bit, mapped from YANG variable /ipsec_ikeless/spd/spd_entry/ipsec_policy_config/processing_info/ipsec_sa_cfg/tunnel/df_bit (enumeration)

    YANG Description: Allow configuring the DF bit when encapsulating
tunnel mode IPsec traffic.  RFC 4301 describes
three options to handle the DF bit during
tunnel encapsulation: clear, set, and copy from
the inner IP header.  This MUST be ignored or
has no meaning when the local/remote
IP addresses are IPv6 addresses.
    """
    return self.__df_bit
      
  def _set_df_bit(self, v, load=False):
    """
    Setter method for df_bit, mapped from YANG variable /ipsec_ikeless/spd/spd_entry/ipsec_policy_config/processing_info/ipsec_sa_cfg/tunnel/df_bit (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_df_bit is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_df_bit() directly.

    YANG Description: Allow configuring the DF bit when encapsulating
tunnel mode IPsec traffic.  RFC 4301 describes
three options to handle the DF bit during
tunnel encapsulation: clear, set, and copy from
the inner IP header.  This MUST be ignored or
has no meaning when the local/remote
IP addresses are IPv6 addresses.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'clear': {}, 'set': {}, 'copy': {}},), default=six.text_type("clear"), is_leaf=True, yang_name="df-bit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='enumeration', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """df_bit must be of a type compatible with enumeration""",
          'defined-type': "ietf-i2nsf-ikeless:enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'clear': {}, 'set': {}, 'copy': {}},), default=six.text_type("clear"), is_leaf=True, yang_name="df-bit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='enumeration', is_config=True)""",
        })

    self.__df_bit = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_df_bit(self):
    self.__df_bit = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'clear': {}, 'set': {}, 'copy': {}},), default=six.text_type("clear"), is_leaf=True, yang_name="df-bit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='enumeration', is_config=True)


  def _get_bypass_dscp(self):
    """
    Getter method for bypass_dscp, mapped from YANG variable /ipsec_ikeless/spd/spd_entry/ipsec_policy_config/processing_info/ipsec_sa_cfg/tunnel/bypass_dscp (boolean)

    YANG Description: If true, to copy the Differentiated Services Code
Point (DSCP) value from inner header to outer header.
If false, to map DSCP values
from an inner header to values in an outer header
following ../dscp-mapping.
    """
    return self.__bypass_dscp
      
  def _set_bypass_dscp(self, v, load=False):
    """
    Setter method for bypass_dscp, mapped from YANG variable /ipsec_ikeless/spd/spd_entry/ipsec_policy_config/processing_info/ipsec_sa_cfg/tunnel/bypass_dscp (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_bypass_dscp is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_bypass_dscp() directly.

    YANG Description: If true, to copy the Differentiated Services Code
Point (DSCP) value from inner header to outer header.
If false, to map DSCP values
from an inner header to values in an outer header
following ../dscp-mapping.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="bypass-dscp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """bypass_dscp must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="bypass-dscp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='boolean', is_config=True)""",
        })

    self.__bypass_dscp = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_bypass_dscp(self):
    self.__bypass_dscp = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="bypass-dscp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='boolean', is_config=True)


  def _get_dscp_mapping(self):
    """
    Getter method for dscp_mapping, mapped from YANG variable /ipsec_ikeless/spd/spd_entry/ipsec_policy_config/processing_info/ipsec_sa_cfg/tunnel/dscp_mapping (list)

    YANG Description: A list that represents an array with the mapping from the
inner DSCP value to outer DSCP value when bypass-dscp is
false.  To express a default mapping in the list where any
other inner dscp value is not matching a node in the list,
a new node has to be included at the end of the list where
the leaf inner-dscp is not defined (ANY) and the leaf
outer-dscp includes the value of the mapping.  If there is
no value set in the leaf outer-dscp, the default value for
this leaf is 0.
    """
    return self.__dscp_mapping
      
  def _set_dscp_mapping(self, v, load=False):
    """
    Setter method for dscp_mapping, mapped from YANG variable /ipsec_ikeless/spd/spd_entry/ipsec_policy_config/processing_info/ipsec_sa_cfg/tunnel/dscp_mapping (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dscp_mapping is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dscp_mapping() directly.

    YANG Description: A list that represents an array with the mapping from the
inner DSCP value to outer DSCP value when bypass-dscp is
false.  To express a default mapping in the list where any
other inner dscp value is not matching a node in the list,
a new node has to be included at the end of the list where
the leaf inner-dscp is not defined (ANY) and the leaf
outer-dscp includes the value of the mapping.  If there is
no value set in the leaf outer-dscp, the default value for
this leaf is 0.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("id",yc_dscp_mapping_ietf_i2nsf_ikeless__ipsec_ikeless_spd_spd_entry_ipsec_policy_config_processing_info_ipsec_sa_cfg_tunnel_dscp_mapping, yang_name="dscp-mapping", parent=self, is_container='list', user_ordered=True, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="dscp-mapping", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """dscp_mapping must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("id",yc_dscp_mapping_ietf_i2nsf_ikeless__ipsec_ikeless_spd_spd_entry_ipsec_policy_config_processing_info_ipsec_sa_cfg_tunnel_dscp_mapping, yang_name="dscp-mapping", parent=self, is_container='list', user_ordered=True, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="dscp-mapping", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='list', is_config=True)""",
        })

    self.__dscp_mapping = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_dscp_mapping(self):
    self.__dscp_mapping = YANGDynClass(base=YANGListType("id",yc_dscp_mapping_ietf_i2nsf_ikeless__ipsec_ikeless_spd_spd_entry_ipsec_policy_config_processing_info_ipsec_sa_cfg_tunnel_dscp_mapping, yang_name="dscp-mapping", parent=self, is_container='list', user_ordered=True, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="dscp-mapping", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='list', is_config=True)

  local_ = __builtin__.property(_get_local_, _set_local_)
  remote = __builtin__.property(_get_remote, _set_remote)
  df_bit = __builtin__.property(_get_df_bit, _set_df_bit)
  bypass_dscp = __builtin__.property(_get_bypass_dscp, _set_bypass_dscp)
  dscp_mapping = __builtin__.property(_get_dscp_mapping, _set_dscp_mapping)


  _pyangbind_elements = OrderedDict([('local_', local_), ('remote', remote), ('df_bit', df_bit), ('bypass_dscp', bypass_dscp), ('dscp_mapping', dscp_mapping), ])


class yc_ipsec_sa_cfg_ietf_i2nsf_ikeless__ipsec_ikeless_spd_spd_entry_ipsec_policy_config_processing_info_ipsec_sa_cfg(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-i2nsf-ikeless - based on the path /ipsec-ikeless/spd/spd-entry/ipsec-policy-config/processing-info/ipsec-sa-cfg. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: IPsec SA configuration included in the SPD
entry.
  """
  __slots__ = ('_path_helper', '_extmethods', '__pfp_flag','__ext_seq_num','__seq_overflow','__stateful_frag_check','__mode','__protocol_parameters','__esp_algorithms','__tunnel',)

  _yang_name = 'ipsec-sa-cfg'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__pfp_flag = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="pfp-flag", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='boolean', is_config=True)
    self.__ext_seq_num = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="ext-seq-num", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='boolean', is_config=True)
    self.__seq_overflow = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="seq-overflow", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='boolean', is_config=True)
    self.__stateful_frag_check = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="stateful-frag-check", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='boolean', is_config=True)
    self.__mode = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'transport': {}, 'tunnel': {}},), default=six.text_type("transport"), is_leaf=True, yang_name="mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='ipsec-mode', is_config=True)
    self.__protocol_parameters = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'esp': {}},), default=six.text_type("esp"), is_leaf=True, yang_name="protocol-parameters", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='ipsec-protocol-params', is_config=True)
    self.__esp_algorithms = YANGDynClass(base=yc_esp_algorithms_ietf_i2nsf_ikeless__ipsec_ikeless_spd_spd_entry_ipsec_policy_config_processing_info_ipsec_sa_cfg_esp_algorithms, is_container='container', yang_name="esp-algorithms", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='container', is_config=True)
    self.__tunnel = YANGDynClass(base=yc_tunnel_ietf_i2nsf_ikeless__ipsec_ikeless_spd_spd_entry_ipsec_policy_config_processing_info_ipsec_sa_cfg_tunnel, is_container='container', yang_name="tunnel", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['ipsec-ikeless', 'spd', 'spd-entry', 'ipsec-policy-config', 'processing-info', 'ipsec-sa-cfg']

  def _get_pfp_flag(self):
    """
    Getter method for pfp_flag, mapped from YANG variable /ipsec_ikeless/spd/spd_entry/ipsec_policy_config/processing_info/ipsec_sa_cfg/pfp_flag (boolean)

    YANG Description: Each selector has a Populate From
Packet (PFP) flag.  If asserted for a
given selector X, the flag indicates
that the IPsec SA to be created should
take its value (local IP address,
remote IP address, Next Layer
Protocol, etc.) for X from the value
in the packet.  Otherwise, the IPsec SA
should take its value(s) for X from
the value(s) in the SPD entry.
    """
    return self.__pfp_flag
      
  def _set_pfp_flag(self, v, load=False):
    """
    Setter method for pfp_flag, mapped from YANG variable /ipsec_ikeless/spd/spd_entry/ipsec_policy_config/processing_info/ipsec_sa_cfg/pfp_flag (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_pfp_flag is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_pfp_flag() directly.

    YANG Description: Each selector has a Populate From
Packet (PFP) flag.  If asserted for a
given selector X, the flag indicates
that the IPsec SA to be created should
take its value (local IP address,
remote IP address, Next Layer
Protocol, etc.) for X from the value
in the packet.  Otherwise, the IPsec SA
should take its value(s) for X from
the value(s) in the SPD entry.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="pfp-flag", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """pfp_flag must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="pfp-flag", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='boolean', is_config=True)""",
        })

    self.__pfp_flag = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_pfp_flag(self):
    self.__pfp_flag = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="pfp-flag", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='boolean', is_config=True)


  def _get_ext_seq_num(self):
    """
    Getter method for ext_seq_num, mapped from YANG variable /ipsec_ikeless/spd/spd_entry/ipsec_policy_config/processing_info/ipsec_sa_cfg/ext_seq_num (boolean)

    YANG Description: True if this IPsec SA is using extended
sequence numbers.  If true, the 64-bit
extended sequence number counter is used;
if false, the normal 32-bit sequence
number counter is used.
    """
    return self.__ext_seq_num
      
  def _set_ext_seq_num(self, v, load=False):
    """
    Setter method for ext_seq_num, mapped from YANG variable /ipsec_ikeless/spd/spd_entry/ipsec_policy_config/processing_info/ipsec_sa_cfg/ext_seq_num (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ext_seq_num is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ext_seq_num() directly.

    YANG Description: True if this IPsec SA is using extended
sequence numbers.  If true, the 64-bit
extended sequence number counter is used;
if false, the normal 32-bit sequence
number counter is used.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="ext-seq-num", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ext_seq_num must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="ext-seq-num", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='boolean', is_config=True)""",
        })

    self.__ext_seq_num = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ext_seq_num(self):
    self.__ext_seq_num = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="ext-seq-num", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='boolean', is_config=True)


  def _get_seq_overflow(self):
    """
    Getter method for seq_overflow, mapped from YANG variable /ipsec_ikeless/spd/spd_entry/ipsec_policy_config/processing_info/ipsec_sa_cfg/seq_overflow (boolean)

    YANG Description: The flag indicating whether
overflow of the sequence number
counter should prevent transmission
of additional packets on the IPsec
SA (false) and, therefore, needs to
be rekeyed or whether rollover is
permitted (true).  If Authenticated
Encryption with Associated Data
(AEAD) is used (leaf
esp-algorithms/encryption/algorithm-type),
this flag MUST be false.  Setting this
flag to true is strongly discouraged.
    """
    return self.__seq_overflow
      
  def _set_seq_overflow(self, v, load=False):
    """
    Setter method for seq_overflow, mapped from YANG variable /ipsec_ikeless/spd/spd_entry/ipsec_policy_config/processing_info/ipsec_sa_cfg/seq_overflow (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_seq_overflow is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_seq_overflow() directly.

    YANG Description: The flag indicating whether
overflow of the sequence number
counter should prevent transmission
of additional packets on the IPsec
SA (false) and, therefore, needs to
be rekeyed or whether rollover is
permitted (true).  If Authenticated
Encryption with Associated Data
(AEAD) is used (leaf
esp-algorithms/encryption/algorithm-type),
this flag MUST be false.  Setting this
flag to true is strongly discouraged.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="seq-overflow", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """seq_overflow must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="seq-overflow", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='boolean', is_config=True)""",
        })

    self.__seq_overflow = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_seq_overflow(self):
    self.__seq_overflow = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="seq-overflow", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='boolean', is_config=True)


  def _get_stateful_frag_check(self):
    """
    Getter method for stateful_frag_check, mapped from YANG variable /ipsec_ikeless/spd/spd_entry/ipsec_policy_config/processing_info/ipsec_sa_cfg/stateful_frag_check (boolean)

    YANG Description: Indicates whether (true) or not (false)
stateful fragment checking applies to
the IPsec SA to be created.
    """
    return self.__stateful_frag_check
      
  def _set_stateful_frag_check(self, v, load=False):
    """
    Setter method for stateful_frag_check, mapped from YANG variable /ipsec_ikeless/spd/spd_entry/ipsec_policy_config/processing_info/ipsec_sa_cfg/stateful_frag_check (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_stateful_frag_check is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_stateful_frag_check() directly.

    YANG Description: Indicates whether (true) or not (false)
stateful fragment checking applies to
the IPsec SA to be created.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="stateful-frag-check", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """stateful_frag_check must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="stateful-frag-check", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='boolean', is_config=True)""",
        })

    self.__stateful_frag_check = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_stateful_frag_check(self):
    self.__stateful_frag_check = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="stateful-frag-check", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='boolean', is_config=True)


  def _get_mode(self):
    """
    Getter method for mode, mapped from YANG variable /ipsec_ikeless/spd/spd_entry/ipsec_policy_config/processing_info/ipsec_sa_cfg/mode (ipsec-mode)

    YANG Description: IPsec SA has to be processed in
transport or tunnel mode.
    """
    return self.__mode
      
  def _set_mode(self, v, load=False):
    """
    Setter method for mode, mapped from YANG variable /ipsec_ikeless/spd/spd_entry/ipsec_policy_config/processing_info/ipsec_sa_cfg/mode (ipsec-mode)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mode is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mode() directly.

    YANG Description: IPsec SA has to be processed in
transport or tunnel mode.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'transport': {}, 'tunnel': {}},), default=six.text_type("transport"), is_leaf=True, yang_name="mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='ipsec-mode', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mode must be of a type compatible with ipsec-mode""",
          'defined-type': "ietf-i2nsf-ikeless:ipsec-mode",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'transport': {}, 'tunnel': {}},), default=six.text_type("transport"), is_leaf=True, yang_name="mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='ipsec-mode', is_config=True)""",
        })

    self.__mode = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mode(self):
    self.__mode = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'transport': {}, 'tunnel': {}},), default=six.text_type("transport"), is_leaf=True, yang_name="mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='ipsec-mode', is_config=True)


  def _get_protocol_parameters(self):
    """
    Getter method for protocol_parameters, mapped from YANG variable /ipsec_ikeless/spd/spd_entry/ipsec_policy_config/processing_info/ipsec_sa_cfg/protocol_parameters (ipsec-protocol-params)

    YANG Description: Security protocol of the IPsec SA.
Only ESP is supported, but it could be
extended in the future.
    """
    return self.__protocol_parameters
      
  def _set_protocol_parameters(self, v, load=False):
    """
    Setter method for protocol_parameters, mapped from YANG variable /ipsec_ikeless/spd/spd_entry/ipsec_policy_config/processing_info/ipsec_sa_cfg/protocol_parameters (ipsec-protocol-params)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_protocol_parameters is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_protocol_parameters() directly.

    YANG Description: Security protocol of the IPsec SA.
Only ESP is supported, but it could be
extended in the future.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'esp': {}},), default=six.text_type("esp"), is_leaf=True, yang_name="protocol-parameters", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='ipsec-protocol-params', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """protocol_parameters must be of a type compatible with ipsec-protocol-params""",
          'defined-type': "ietf-i2nsf-ikeless:ipsec-protocol-params",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'esp': {}},), default=six.text_type("esp"), is_leaf=True, yang_name="protocol-parameters", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='ipsec-protocol-params', is_config=True)""",
        })

    self.__protocol_parameters = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_protocol_parameters(self):
    self.__protocol_parameters = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'esp': {}},), default=six.text_type("esp"), is_leaf=True, yang_name="protocol-parameters", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='ipsec-protocol-params', is_config=True)


  def _get_esp_algorithms(self):
    """
    Getter method for esp_algorithms, mapped from YANG variable /ipsec_ikeless/spd/spd_entry/ipsec_policy_config/processing_info/ipsec_sa_cfg/esp_algorithms (container)

    YANG Description: Configuration of Encapsulating
Security Payload (ESP) parameters and
algorithms.
    """
    return self.__esp_algorithms
      
  def _set_esp_algorithms(self, v, load=False):
    """
    Setter method for esp_algorithms, mapped from YANG variable /ipsec_ikeless/spd/spd_entry/ipsec_policy_config/processing_info/ipsec_sa_cfg/esp_algorithms (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_esp_algorithms is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_esp_algorithms() directly.

    YANG Description: Configuration of Encapsulating
Security Payload (ESP) parameters and
algorithms.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_esp_algorithms_ietf_i2nsf_ikeless__ipsec_ikeless_spd_spd_entry_ipsec_policy_config_processing_info_ipsec_sa_cfg_esp_algorithms, is_container='container', yang_name="esp-algorithms", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """esp_algorithms must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_esp_algorithms_ietf_i2nsf_ikeless__ipsec_ikeless_spd_spd_entry_ipsec_policy_config_processing_info_ipsec_sa_cfg_esp_algorithms, is_container='container', yang_name="esp-algorithms", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='container', is_config=True)""",
        })

    self.__esp_algorithms = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_esp_algorithms(self):
    self.__esp_algorithms = YANGDynClass(base=yc_esp_algorithms_ietf_i2nsf_ikeless__ipsec_ikeless_spd_spd_entry_ipsec_policy_config_processing_info_ipsec_sa_cfg_esp_algorithms, is_container='container', yang_name="esp-algorithms", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='container', is_config=True)


  def _get_tunnel(self):
    """
    Getter method for tunnel, mapped from YANG variable /ipsec_ikeless/spd/spd_entry/ipsec_policy_config/processing_info/ipsec_sa_cfg/tunnel (container)

    YANG Description: IPsec tunnel endpoints definition.
    """
    return self.__tunnel
      
  def _set_tunnel(self, v, load=False):
    """
    Setter method for tunnel, mapped from YANG variable /ipsec_ikeless/spd/spd_entry/ipsec_policy_config/processing_info/ipsec_sa_cfg/tunnel (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_tunnel is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_tunnel() directly.

    YANG Description: IPsec tunnel endpoints definition.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_tunnel_ietf_i2nsf_ikeless__ipsec_ikeless_spd_spd_entry_ipsec_policy_config_processing_info_ipsec_sa_cfg_tunnel, is_container='container', yang_name="tunnel", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """tunnel must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_tunnel_ietf_i2nsf_ikeless__ipsec_ikeless_spd_spd_entry_ipsec_policy_config_processing_info_ipsec_sa_cfg_tunnel, is_container='container', yang_name="tunnel", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='container', is_config=True)""",
        })

    self.__tunnel = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_tunnel(self):
    self.__tunnel = YANGDynClass(base=yc_tunnel_ietf_i2nsf_ikeless__ipsec_ikeless_spd_spd_entry_ipsec_policy_config_processing_info_ipsec_sa_cfg_tunnel, is_container='container', yang_name="tunnel", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='container', is_config=True)

  pfp_flag = __builtin__.property(_get_pfp_flag, _set_pfp_flag)
  ext_seq_num = __builtin__.property(_get_ext_seq_num, _set_ext_seq_num)
  seq_overflow = __builtin__.property(_get_seq_overflow, _set_seq_overflow)
  stateful_frag_check = __builtin__.property(_get_stateful_frag_check, _set_stateful_frag_check)
  mode = __builtin__.property(_get_mode, _set_mode)
  protocol_parameters = __builtin__.property(_get_protocol_parameters, _set_protocol_parameters)
  esp_algorithms = __builtin__.property(_get_esp_algorithms, _set_esp_algorithms)
  tunnel = __builtin__.property(_get_tunnel, _set_tunnel)


  _pyangbind_elements = OrderedDict([('pfp_flag', pfp_flag), ('ext_seq_num', ext_seq_num), ('seq_overflow', seq_overflow), ('stateful_frag_check', stateful_frag_check), ('mode', mode), ('protocol_parameters', protocol_parameters), ('esp_algorithms', esp_algorithms), ('tunnel', tunnel), ])


class yc_processing_info_ietf_i2nsf_ikeless__ipsec_ikeless_spd_spd_entry_ipsec_policy_config_processing_info(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-i2nsf-ikeless - based on the path /ipsec-ikeless/spd/spd-entry/ipsec-policy-config/processing-info. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: SPD processing.  If the required processing
action is protect, it contains the required
information to process the packet.
  """
  __slots__ = ('_path_helper', '_extmethods', '__action','__ipsec_sa_cfg',)

  _yang_name = 'processing-info'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__action = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'protect': {}, 'bypass': {}, 'discard': {}},), default=six.text_type("discard"), is_leaf=True, yang_name="action", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='ipsec-spd-action', is_config=True)
    self.__ipsec_sa_cfg = YANGDynClass(base=yc_ipsec_sa_cfg_ietf_i2nsf_ikeless__ipsec_ikeless_spd_spd_entry_ipsec_policy_config_processing_info_ipsec_sa_cfg, is_container='container', yang_name="ipsec-sa-cfg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['ipsec-ikeless', 'spd', 'spd-entry', 'ipsec-policy-config', 'processing-info']

  def _get_action(self):
    """
    Getter method for action, mapped from YANG variable /ipsec_ikeless/spd/spd_entry/ipsec_policy_config/processing_info/action (ipsec-spd-action)

    YANG Description: If bypass or discard, container
ipsec-sa-cfg is empty.
    """
    return self.__action
      
  def _set_action(self, v, load=False):
    """
    Setter method for action, mapped from YANG variable /ipsec_ikeless/spd/spd_entry/ipsec_policy_config/processing_info/action (ipsec-spd-action)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_action is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_action() directly.

    YANG Description: If bypass or discard, container
ipsec-sa-cfg is empty.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'protect': {}, 'bypass': {}, 'discard': {}},), default=six.text_type("discard"), is_leaf=True, yang_name="action", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='ipsec-spd-action', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """action must be of a type compatible with ipsec-spd-action""",
          'defined-type': "ietf-i2nsf-ikeless:ipsec-spd-action",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'protect': {}, 'bypass': {}, 'discard': {}},), default=six.text_type("discard"), is_leaf=True, yang_name="action", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='ipsec-spd-action', is_config=True)""",
        })

    self.__action = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_action(self):
    self.__action = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'protect': {}, 'bypass': {}, 'discard': {}},), default=six.text_type("discard"), is_leaf=True, yang_name="action", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='ipsec-spd-action', is_config=True)


  def _get_ipsec_sa_cfg(self):
    """
    Getter method for ipsec_sa_cfg, mapped from YANG variable /ipsec_ikeless/spd/spd_entry/ipsec_policy_config/processing_info/ipsec_sa_cfg (container)

    YANG Description: IPsec SA configuration included in the SPD
entry.
    """
    return self.__ipsec_sa_cfg
      
  def _set_ipsec_sa_cfg(self, v, load=False):
    """
    Setter method for ipsec_sa_cfg, mapped from YANG variable /ipsec_ikeless/spd/spd_entry/ipsec_policy_config/processing_info/ipsec_sa_cfg (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ipsec_sa_cfg is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ipsec_sa_cfg() directly.

    YANG Description: IPsec SA configuration included in the SPD
entry.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_ipsec_sa_cfg_ietf_i2nsf_ikeless__ipsec_ikeless_spd_spd_entry_ipsec_policy_config_processing_info_ipsec_sa_cfg, is_container='container', yang_name="ipsec-sa-cfg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ipsec_sa_cfg must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_ipsec_sa_cfg_ietf_i2nsf_ikeless__ipsec_ikeless_spd_spd_entry_ipsec_policy_config_processing_info_ipsec_sa_cfg, is_container='container', yang_name="ipsec-sa-cfg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='container', is_config=True)""",
        })

    self.__ipsec_sa_cfg = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ipsec_sa_cfg(self):
    self.__ipsec_sa_cfg = YANGDynClass(base=yc_ipsec_sa_cfg_ietf_i2nsf_ikeless__ipsec_ikeless_spd_spd_entry_ipsec_policy_config_processing_info_ipsec_sa_cfg, is_container='container', yang_name="ipsec-sa-cfg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='container', is_config=True)

  action = __builtin__.property(_get_action, _set_action)
  ipsec_sa_cfg = __builtin__.property(_get_ipsec_sa_cfg, _set_ipsec_sa_cfg)


  _pyangbind_elements = OrderedDict([('action', action), ('ipsec_sa_cfg', ipsec_sa_cfg), ])


class yc_ipsec_policy_config_ietf_i2nsf_ikeless__ipsec_ikeless_spd_spd_entry_ipsec_policy_config(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-i2nsf-ikeless - based on the path /ipsec-ikeless/spd/spd-entry/ipsec-policy-config. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This container carries the
configuration of an IPsec policy.
  """
  __slots__ = ('_path_helper', '_extmethods', '__anti_replay_window_size','__traffic_selector','__processing_info',)

  _yang_name = 'ipsec-policy-config'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__anti_replay_window_size = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(64), is_leaf=True, yang_name="anti-replay-window-size", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='uint32', is_config=True)
    self.__traffic_selector = YANGDynClass(base=yc_traffic_selector_ietf_i2nsf_ikeless__ipsec_ikeless_spd_spd_entry_ipsec_policy_config_traffic_selector, is_container='container', yang_name="traffic-selector", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='container', is_config=True)
    self.__processing_info = YANGDynClass(base=yc_processing_info_ietf_i2nsf_ikeless__ipsec_ikeless_spd_spd_entry_ipsec_policy_config_processing_info, is_container='container', yang_name="processing-info", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['ipsec-ikeless', 'spd', 'spd-entry', 'ipsec-policy-config']

  def _get_anti_replay_window_size(self):
    """
    Getter method for anti_replay_window_size, mapped from YANG variable /ipsec_ikeless/spd/spd_entry/ipsec_policy_config/anti_replay_window_size (uint32)

    YANG Description: To set the anti-replay window size.
The default value is set
to 64, following the recommendation in RFC 4303.
    """
    return self.__anti_replay_window_size
      
  def _set_anti_replay_window_size(self, v, load=False):
    """
    Setter method for anti_replay_window_size, mapped from YANG variable /ipsec_ikeless/spd/spd_entry/ipsec_policy_config/anti_replay_window_size (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_anti_replay_window_size is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_anti_replay_window_size() directly.

    YANG Description: To set the anti-replay window size.
The default value is set
to 64, following the recommendation in RFC 4303.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(64), is_leaf=True, yang_name="anti-replay-window-size", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """anti_replay_window_size must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(64), is_leaf=True, yang_name="anti-replay-window-size", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='uint32', is_config=True)""",
        })

    self.__anti_replay_window_size = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_anti_replay_window_size(self):
    self.__anti_replay_window_size = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(64), is_leaf=True, yang_name="anti-replay-window-size", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='uint32', is_config=True)


  def _get_traffic_selector(self):
    """
    Getter method for traffic_selector, mapped from YANG variable /ipsec_ikeless/spd/spd_entry/ipsec_policy_config/traffic_selector (container)

    YANG Description: Packets are selected for
processing actions based on Traffic Selector
values, which refer to IP and inner protocol
header information.
    """
    return self.__traffic_selector
      
  def _set_traffic_selector(self, v, load=False):
    """
    Setter method for traffic_selector, mapped from YANG variable /ipsec_ikeless/spd/spd_entry/ipsec_policy_config/traffic_selector (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_traffic_selector is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_traffic_selector() directly.

    YANG Description: Packets are selected for
processing actions based on Traffic Selector
values, which refer to IP and inner protocol
header information.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_traffic_selector_ietf_i2nsf_ikeless__ipsec_ikeless_spd_spd_entry_ipsec_policy_config_traffic_selector, is_container='container', yang_name="traffic-selector", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """traffic_selector must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_traffic_selector_ietf_i2nsf_ikeless__ipsec_ikeless_spd_spd_entry_ipsec_policy_config_traffic_selector, is_container='container', yang_name="traffic-selector", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='container', is_config=True)""",
        })

    self.__traffic_selector = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_traffic_selector(self):
    self.__traffic_selector = YANGDynClass(base=yc_traffic_selector_ietf_i2nsf_ikeless__ipsec_ikeless_spd_spd_entry_ipsec_policy_config_traffic_selector, is_container='container', yang_name="traffic-selector", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='container', is_config=True)


  def _get_processing_info(self):
    """
    Getter method for processing_info, mapped from YANG variable /ipsec_ikeless/spd/spd_entry/ipsec_policy_config/processing_info (container)

    YANG Description: SPD processing.  If the required processing
action is protect, it contains the required
information to process the packet.
    """
    return self.__processing_info
      
  def _set_processing_info(self, v, load=False):
    """
    Setter method for processing_info, mapped from YANG variable /ipsec_ikeless/spd/spd_entry/ipsec_policy_config/processing_info (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_processing_info is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_processing_info() directly.

    YANG Description: SPD processing.  If the required processing
action is protect, it contains the required
information to process the packet.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_processing_info_ietf_i2nsf_ikeless__ipsec_ikeless_spd_spd_entry_ipsec_policy_config_processing_info, is_container='container', yang_name="processing-info", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """processing_info must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_processing_info_ietf_i2nsf_ikeless__ipsec_ikeless_spd_spd_entry_ipsec_policy_config_processing_info, is_container='container', yang_name="processing-info", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='container', is_config=True)""",
        })

    self.__processing_info = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_processing_info(self):
    self.__processing_info = YANGDynClass(base=yc_processing_info_ietf_i2nsf_ikeless__ipsec_ikeless_spd_spd_entry_ipsec_policy_config_processing_info, is_container='container', yang_name="processing-info", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='container', is_config=True)

  anti_replay_window_size = __builtin__.property(_get_anti_replay_window_size, _set_anti_replay_window_size)
  traffic_selector = __builtin__.property(_get_traffic_selector, _set_traffic_selector)
  processing_info = __builtin__.property(_get_processing_info, _set_processing_info)


  _pyangbind_elements = OrderedDict([('anti_replay_window_size', anti_replay_window_size), ('traffic_selector', traffic_selector), ('processing_info', processing_info), ])


class yc_spd_entry_ietf_i2nsf_ikeless__ipsec_ikeless_spd_spd_entry(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-i2nsf-ikeless - based on the path /ipsec-ikeless/spd/spd-entry. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: The SPD is represented as a list of SPD
entries, where each SPD entry represents an
IPsec policy.
  """
  __slots__ = ('_path_helper', '_extmethods', '__name','__direction','__reqid','__ipsec_policy_config',)

  _yang_name = 'spd-entry'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='string', is_config=True)
    self.__direction = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'inbound': {}, 'outbound': {}},), is_leaf=True, yang_name="direction", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='nsfikec:ipsec-traffic-direction', is_config=True)
    self.__reqid = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), default=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64)(0), is_leaf=True, yang_name="reqid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='uint64', is_config=True)
    self.__ipsec_policy_config = YANGDynClass(base=yc_ipsec_policy_config_ietf_i2nsf_ikeless__ipsec_ikeless_spd_spd_entry_ipsec_policy_config, is_container='container', yang_name="ipsec-policy-config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['ipsec-ikeless', 'spd', 'spd-entry']

  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /ipsec_ikeless/spd/spd_entry/name (string)

    YANG Description: SPD-entry-unique name to identify this
entry.
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /ipsec_ikeless/spd/spd_entry/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: SPD-entry-unique name to identify this
entry.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='string', is_config=True)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='string', is_config=True)


  def _get_direction(self):
    """
    Getter method for direction, mapped from YANG variable /ipsec_ikeless/spd/spd_entry/direction (nsfikec:ipsec-traffic-direction)

    YANG Description: Inbound traffic or outbound
traffic.  In the IKE-less case, the
I2NSF Controller needs to
specify the policy direction to be
applied in the NSF.  In the IKE case,
this direction does not need to be
specified, since IKE
will determine the direction that the
IPsec policy will require.
    """
    return self.__direction
      
  def _set_direction(self, v, load=False):
    """
    Setter method for direction, mapped from YANG variable /ipsec_ikeless/spd/spd_entry/direction (nsfikec:ipsec-traffic-direction)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_direction is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_direction() directly.

    YANG Description: Inbound traffic or outbound
traffic.  In the IKE-less case, the
I2NSF Controller needs to
specify the policy direction to be
applied in the NSF.  In the IKE case,
this direction does not need to be
specified, since IKE
will determine the direction that the
IPsec policy will require.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'inbound': {}, 'outbound': {}},), is_leaf=True, yang_name="direction", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='nsfikec:ipsec-traffic-direction', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """direction must be of a type compatible with nsfikec:ipsec-traffic-direction""",
          'defined-type': "nsfikec:ipsec-traffic-direction",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'inbound': {}, 'outbound': {}},), is_leaf=True, yang_name="direction", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='nsfikec:ipsec-traffic-direction', is_config=True)""",
        })

    self.__direction = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_direction(self):
    self.__direction = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'inbound': {}, 'outbound': {}},), is_leaf=True, yang_name="direction", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='nsfikec:ipsec-traffic-direction', is_config=True)


  def _get_reqid(self):
    """
    Getter method for reqid, mapped from YANG variable /ipsec_ikeless/spd/spd_entry/reqid (uint64)

    YANG Description: This value allows linking this
IPsec policy with IPsec SAs with the
same reqid.  It is only required in
the IKE-less model since, in the IKE
case, this link is handled internally
by IKE.
    """
    return self.__reqid
      
  def _set_reqid(self, v, load=False):
    """
    Setter method for reqid, mapped from YANG variable /ipsec_ikeless/spd/spd_entry/reqid (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_reqid is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_reqid() directly.

    YANG Description: This value allows linking this
IPsec policy with IPsec SAs with the
same reqid.  It is only required in
the IKE-less model since, in the IKE
case, this link is handled internally
by IKE.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), default=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64)(0), is_leaf=True, yang_name="reqid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='uint64', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """reqid must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), default=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64)(0), is_leaf=True, yang_name="reqid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='uint64', is_config=True)""",
        })

    self.__reqid = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_reqid(self):
    self.__reqid = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), default=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64)(0), is_leaf=True, yang_name="reqid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='uint64', is_config=True)


  def _get_ipsec_policy_config(self):
    """
    Getter method for ipsec_policy_config, mapped from YANG variable /ipsec_ikeless/spd/spd_entry/ipsec_policy_config (container)

    YANG Description: This container carries the
configuration of an IPsec policy.
    """
    return self.__ipsec_policy_config
      
  def _set_ipsec_policy_config(self, v, load=False):
    """
    Setter method for ipsec_policy_config, mapped from YANG variable /ipsec_ikeless/spd/spd_entry/ipsec_policy_config (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ipsec_policy_config is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ipsec_policy_config() directly.

    YANG Description: This container carries the
configuration of an IPsec policy.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_ipsec_policy_config_ietf_i2nsf_ikeless__ipsec_ikeless_spd_spd_entry_ipsec_policy_config, is_container='container', yang_name="ipsec-policy-config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ipsec_policy_config must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_ipsec_policy_config_ietf_i2nsf_ikeless__ipsec_ikeless_spd_spd_entry_ipsec_policy_config, is_container='container', yang_name="ipsec-policy-config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='container', is_config=True)""",
        })

    self.__ipsec_policy_config = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ipsec_policy_config(self):
    self.__ipsec_policy_config = YANGDynClass(base=yc_ipsec_policy_config_ietf_i2nsf_ikeless__ipsec_ikeless_spd_spd_entry_ipsec_policy_config, is_container='container', yang_name="ipsec-policy-config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='container', is_config=True)

  name = __builtin__.property(_get_name, _set_name)
  direction = __builtin__.property(_get_direction, _set_direction)
  reqid = __builtin__.property(_get_reqid, _set_reqid)
  ipsec_policy_config = __builtin__.property(_get_ipsec_policy_config, _set_ipsec_policy_config)


  _pyangbind_elements = OrderedDict([('name', name), ('direction', direction), ('reqid', reqid), ('ipsec_policy_config', ipsec_policy_config), ])


class yc_spd_ietf_i2nsf_ikeless__ipsec_ikeless_spd(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-i2nsf-ikeless - based on the path /ipsec-ikeless/spd. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configuration of the Security Policy Database
(SPD).
  """
  __slots__ = ('_path_helper', '_extmethods', '__spd_entry',)

  _yang_name = 'spd'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__spd_entry = YANGDynClass(base=YANGListType("name",yc_spd_entry_ietf_i2nsf_ikeless__ipsec_ikeless_spd_spd_entry, yang_name="spd-entry", parent=self, is_container='list', user_ordered=True, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="spd-entry", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['ipsec-ikeless', 'spd']

  def _get_spd_entry(self):
    """
    Getter method for spd_entry, mapped from YANG variable /ipsec_ikeless/spd/spd_entry (list)

    YANG Description: The SPD is represented as a list of SPD
entries, where each SPD entry represents an
IPsec policy.
    """
    return self.__spd_entry
      
  def _set_spd_entry(self, v, load=False):
    """
    Setter method for spd_entry, mapped from YANG variable /ipsec_ikeless/spd/spd_entry (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_spd_entry is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_spd_entry() directly.

    YANG Description: The SPD is represented as a list of SPD
entries, where each SPD entry represents an
IPsec policy.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("name",yc_spd_entry_ietf_i2nsf_ikeless__ipsec_ikeless_spd_spd_entry, yang_name="spd-entry", parent=self, is_container='list', user_ordered=True, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="spd-entry", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """spd_entry must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("name",yc_spd_entry_ietf_i2nsf_ikeless__ipsec_ikeless_spd_spd_entry, yang_name="spd-entry", parent=self, is_container='list', user_ordered=True, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="spd-entry", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='list', is_config=True)""",
        })

    self.__spd_entry = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_spd_entry(self):
    self.__spd_entry = YANGDynClass(base=YANGListType("name",yc_spd_entry_ietf_i2nsf_ikeless__ipsec_ikeless_spd_spd_entry, yang_name="spd-entry", parent=self, is_container='list', user_ordered=True, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="spd-entry", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='list', is_config=True)

  spd_entry = __builtin__.property(_get_spd_entry, _set_spd_entry)


  _pyangbind_elements = OrderedDict([('spd_entry', spd_entry), ])


class yc_local_ports_ietf_i2nsf_ikeless__ipsec_ikeless_sad_sad_entry_ipsec_sa_config_traffic_selector_local_ports(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-i2nsf-ikeless - based on the path /ipsec-ikeless/sad/sad-entry/ipsec-sa-config/traffic-selector/local-ports. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of local ports. When the inner
protocol is ICMP, this 16-bit value
represents code and type.
If this list is not defined,
it is assumed that start and
end are 0 by default (any port).
  """
  __slots__ = ('_path_helper', '_extmethods', '__start','__end',)

  _yang_name = 'local-ports'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__start = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..65535']}), is_leaf=True, yang_name="start", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='inet:port-number', is_config=True)
    self.__end = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..65535']}), is_leaf=True, yang_name="end", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='inet:port-number', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['ipsec-ikeless', 'sad', 'sad-entry', 'ipsec-sa-config', 'traffic-selector', 'local-ports']

  def _get_start(self):
    """
    Getter method for start, mapped from YANG variable /ipsec_ikeless/sad/sad_entry/ipsec_sa_config/traffic_selector/local_ports/start (inet:port-number)

    YANG Description: Start port number.
    """
    return self.__start
      
  def _set_start(self, v, load=False):
    """
    Setter method for start, mapped from YANG variable /ipsec_ikeless/sad/sad_entry/ipsec_sa_config/traffic_selector/local_ports/start (inet:port-number)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_start is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_start() directly.

    YANG Description: Start port number.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..65535']}), is_leaf=True, yang_name="start", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='inet:port-number', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """start must be of a type compatible with inet:port-number""",
          'defined-type': "inet:port-number",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..65535']}), is_leaf=True, yang_name="start", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='inet:port-number', is_config=True)""",
        })

    self.__start = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_start(self):
    self.__start = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..65535']}), is_leaf=True, yang_name="start", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='inet:port-number', is_config=True)


  def _get_end(self):
    """
    Getter method for end, mapped from YANG variable /ipsec_ikeless/sad/sad_entry/ipsec_sa_config/traffic_selector/local_ports/end (inet:port-number)

    YANG Description: End port number.  To express a single port, set
the same value as start and end.
    """
    return self.__end
      
  def _set_end(self, v, load=False):
    """
    Setter method for end, mapped from YANG variable /ipsec_ikeless/sad/sad_entry/ipsec_sa_config/traffic_selector/local_ports/end (inet:port-number)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_end is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_end() directly.

    YANG Description: End port number.  To express a single port, set
the same value as start and end.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..65535']}), is_leaf=True, yang_name="end", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='inet:port-number', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """end must be of a type compatible with inet:port-number""",
          'defined-type': "inet:port-number",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..65535']}), is_leaf=True, yang_name="end", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='inet:port-number', is_config=True)""",
        })

    self.__end = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_end(self):
    self.__end = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..65535']}), is_leaf=True, yang_name="end", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='inet:port-number', is_config=True)

  start = __builtin__.property(_get_start, _set_start)
  end = __builtin__.property(_get_end, _set_end)


  _pyangbind_elements = OrderedDict([('start', start), ('end', end), ])


class yc_remote_ports_ietf_i2nsf_ikeless__ipsec_ikeless_sad_sad_entry_ipsec_sa_config_traffic_selector_remote_ports(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-i2nsf-ikeless - based on the path /ipsec-ikeless/sad/sad-entry/ipsec-sa-config/traffic-selector/remote-ports. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of remote ports. When the upper layer
protocol is ICMP, this 16-bit value represents
code and type.  If this list is not defined,
it is assumed that start and end are 0 by
default (any port).
  """
  __slots__ = ('_path_helper', '_extmethods', '__start','__end',)

  _yang_name = 'remote-ports'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__start = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..65535']}), is_leaf=True, yang_name="start", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='inet:port-number', is_config=True)
    self.__end = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..65535']}), is_leaf=True, yang_name="end", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='inet:port-number', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['ipsec-ikeless', 'sad', 'sad-entry', 'ipsec-sa-config', 'traffic-selector', 'remote-ports']

  def _get_start(self):
    """
    Getter method for start, mapped from YANG variable /ipsec_ikeless/sad/sad_entry/ipsec_sa_config/traffic_selector/remote_ports/start (inet:port-number)

    YANG Description: Start port number.
    """
    return self.__start
      
  def _set_start(self, v, load=False):
    """
    Setter method for start, mapped from YANG variable /ipsec_ikeless/sad/sad_entry/ipsec_sa_config/traffic_selector/remote_ports/start (inet:port-number)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_start is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_start() directly.

    YANG Description: Start port number.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..65535']}), is_leaf=True, yang_name="start", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='inet:port-number', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """start must be of a type compatible with inet:port-number""",
          'defined-type': "inet:port-number",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..65535']}), is_leaf=True, yang_name="start", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='inet:port-number', is_config=True)""",
        })

    self.__start = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_start(self):
    self.__start = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..65535']}), is_leaf=True, yang_name="start", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='inet:port-number', is_config=True)


  def _get_end(self):
    """
    Getter method for end, mapped from YANG variable /ipsec_ikeless/sad/sad_entry/ipsec_sa_config/traffic_selector/remote_ports/end (inet:port-number)

    YANG Description: End port number.  To express a single port, set
the same value as start and end.
    """
    return self.__end
      
  def _set_end(self, v, load=False):
    """
    Setter method for end, mapped from YANG variable /ipsec_ikeless/sad/sad_entry/ipsec_sa_config/traffic_selector/remote_ports/end (inet:port-number)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_end is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_end() directly.

    YANG Description: End port number.  To express a single port, set
the same value as start and end.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..65535']}), is_leaf=True, yang_name="end", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='inet:port-number', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """end must be of a type compatible with inet:port-number""",
          'defined-type': "inet:port-number",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..65535']}), is_leaf=True, yang_name="end", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='inet:port-number', is_config=True)""",
        })

    self.__end = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_end(self):
    self.__end = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..65535']}), is_leaf=True, yang_name="end", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='inet:port-number', is_config=True)

  start = __builtin__.property(_get_start, _set_start)
  end = __builtin__.property(_get_end, _set_end)


  _pyangbind_elements = OrderedDict([('start', start), ('end', end), ])


class yc_traffic_selector_ietf_i2nsf_ikeless__ipsec_ikeless_sad_sad_entry_ipsec_sa_config_traffic_selector(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-i2nsf-ikeless - based on the path /ipsec-ikeless/sad/sad-entry/ipsec-sa-config/traffic-selector. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: The IPsec SA Traffic Selector.
  """
  __slots__ = ('_path_helper', '_extmethods', '__local_prefix','__remote_prefix','__inner_protocol','__local_ports','__remote_ports',)

  _yang_name = 'traffic-selector'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__local_prefix = YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])/(([0-9])|([1-2][0-9])|(3[0-2]))'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(/(([0-9])|([0-9]{2})|(1[0-1][0-9])|(12[0-8])))'}),], is_leaf=True, yang_name="local-prefix", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='inet:ip-prefix', is_config=True)
    self.__remote_prefix = YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])/(([0-9])|([1-2][0-9])|(3[0-2]))'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(/(([0-9])|([0-9]{2})|(1[0-1][0-9])|(12[0-8])))'}),], is_leaf=True, yang_name="remote-prefix", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='inet:ip-prefix', is_config=True)
    self.__inner_protocol = YANGDynClass(base=[RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8),RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'any': {'value': 256}},),], default=six.text_type("a"), is_leaf=True, yang_name="inner-protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='ipsec-inner-protocol', is_config=True)
    self.__local_ports = YANGDynClass(base=YANGListType("start end",yc_local_ports_ietf_i2nsf_ikeless__ipsec_ikeless_sad_sad_entry_ipsec_sa_config_traffic_selector_local_ports, yang_name="local-ports", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='start end', extensions=None), is_container='list', yang_name="local-ports", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='list', is_config=True)
    self.__remote_ports = YANGDynClass(base=YANGListType("start end",yc_remote_ports_ietf_i2nsf_ikeless__ipsec_ikeless_sad_sad_entry_ipsec_sa_config_traffic_selector_remote_ports, yang_name="remote-ports", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='start end', extensions=None), is_container='list', yang_name="remote-ports", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['ipsec-ikeless', 'sad', 'sad-entry', 'ipsec-sa-config', 'traffic-selector']

  def _get_local_prefix(self):
    """
    Getter method for local_prefix, mapped from YANG variable /ipsec_ikeless/sad/sad_entry/ipsec_sa_config/traffic_selector/local_prefix (inet:ip-prefix)

    YANG Description: Local IP address prefix.
    """
    return self.__local_prefix
      
  def _set_local_prefix(self, v, load=False):
    """
    Setter method for local_prefix, mapped from YANG variable /ipsec_ikeless/sad/sad_entry/ipsec_sa_config/traffic_selector/local_prefix (inet:ip-prefix)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_local_prefix is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_local_prefix() directly.

    YANG Description: Local IP address prefix.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])/(([0-9])|([1-2][0-9])|(3[0-2]))'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(/(([0-9])|([0-9]{2})|(1[0-1][0-9])|(12[0-8])))'}),], is_leaf=True, yang_name="local-prefix", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='inet:ip-prefix', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """local_prefix must be of a type compatible with inet:ip-prefix""",
          'defined-type': "inet:ip-prefix",
          'generated-type': """YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])/(([0-9])|([1-2][0-9])|(3[0-2]))'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(/(([0-9])|([0-9]{2})|(1[0-1][0-9])|(12[0-8])))'}),], is_leaf=True, yang_name="local-prefix", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='inet:ip-prefix', is_config=True)""",
        })

    self.__local_prefix = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_local_prefix(self):
    self.__local_prefix = YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])/(([0-9])|([1-2][0-9])|(3[0-2]))'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(/(([0-9])|([0-9]{2})|(1[0-1][0-9])|(12[0-8])))'}),], is_leaf=True, yang_name="local-prefix", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='inet:ip-prefix', is_config=True)


  def _get_remote_prefix(self):
    """
    Getter method for remote_prefix, mapped from YANG variable /ipsec_ikeless/sad/sad_entry/ipsec_sa_config/traffic_selector/remote_prefix (inet:ip-prefix)

    YANG Description: Remote IP address prefix.
    """
    return self.__remote_prefix
      
  def _set_remote_prefix(self, v, load=False):
    """
    Setter method for remote_prefix, mapped from YANG variable /ipsec_ikeless/sad/sad_entry/ipsec_sa_config/traffic_selector/remote_prefix (inet:ip-prefix)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_remote_prefix is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_remote_prefix() directly.

    YANG Description: Remote IP address prefix.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])/(([0-9])|([1-2][0-9])|(3[0-2]))'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(/(([0-9])|([0-9]{2})|(1[0-1][0-9])|(12[0-8])))'}),], is_leaf=True, yang_name="remote-prefix", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='inet:ip-prefix', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """remote_prefix must be of a type compatible with inet:ip-prefix""",
          'defined-type': "inet:ip-prefix",
          'generated-type': """YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])/(([0-9])|([1-2][0-9])|(3[0-2]))'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(/(([0-9])|([0-9]{2})|(1[0-1][0-9])|(12[0-8])))'}),], is_leaf=True, yang_name="remote-prefix", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='inet:ip-prefix', is_config=True)""",
        })

    self.__remote_prefix = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_remote_prefix(self):
    self.__remote_prefix = YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])/(([0-9])|([1-2][0-9])|(3[0-2]))'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(/(([0-9])|([0-9]{2})|(1[0-1][0-9])|(12[0-8])))'}),], is_leaf=True, yang_name="remote-prefix", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='inet:ip-prefix', is_config=True)


  def _get_inner_protocol(self):
    """
    Getter method for inner_protocol, mapped from YANG variable /ipsec_ikeless/sad/sad_entry/ipsec_sa_config/traffic_selector/inner_protocol (ipsec-inner-protocol)

    YANG Description: Inner protocol that is going to be
protected with IPsec.
    """
    return self.__inner_protocol
      
  def _set_inner_protocol(self, v, load=False):
    """
    Setter method for inner_protocol, mapped from YANG variable /ipsec_ikeless/sad/sad_entry/ipsec_sa_config/traffic_selector/inner_protocol (ipsec-inner-protocol)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_inner_protocol is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_inner_protocol() directly.

    YANG Description: Inner protocol that is going to be
protected with IPsec.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=[RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8),RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'any': {'value': 256}},),], default=six.text_type("a"), is_leaf=True, yang_name="inner-protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='ipsec-inner-protocol', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """inner_protocol must be of a type compatible with ipsec-inner-protocol""",
          'defined-type': "ietf-i2nsf-ikeless:ipsec-inner-protocol",
          'generated-type': """YANGDynClass(base=[RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8),RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'any': {'value': 256}},),], default=six.text_type("a"), is_leaf=True, yang_name="inner-protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='ipsec-inner-protocol', is_config=True)""",
        })

    self.__inner_protocol = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_inner_protocol(self):
    self.__inner_protocol = YANGDynClass(base=[RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8),RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'any': {'value': 256}},),], default=six.text_type("a"), is_leaf=True, yang_name="inner-protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='ipsec-inner-protocol', is_config=True)


  def _get_local_ports(self):
    """
    Getter method for local_ports, mapped from YANG variable /ipsec_ikeless/sad/sad_entry/ipsec_sa_config/traffic_selector/local_ports (list)

    YANG Description: List of local ports. When the inner
protocol is ICMP, this 16-bit value
represents code and type.
If this list is not defined,
it is assumed that start and
end are 0 by default (any port).
    """
    return self.__local_ports
      
  def _set_local_ports(self, v, load=False):
    """
    Setter method for local_ports, mapped from YANG variable /ipsec_ikeless/sad/sad_entry/ipsec_sa_config/traffic_selector/local_ports (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_local_ports is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_local_ports() directly.

    YANG Description: List of local ports. When the inner
protocol is ICMP, this 16-bit value
represents code and type.
If this list is not defined,
it is assumed that start and
end are 0 by default (any port).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("start end",yc_local_ports_ietf_i2nsf_ikeless__ipsec_ikeless_sad_sad_entry_ipsec_sa_config_traffic_selector_local_ports, yang_name="local-ports", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='start end', extensions=None), is_container='list', yang_name="local-ports", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """local_ports must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("start end",yc_local_ports_ietf_i2nsf_ikeless__ipsec_ikeless_sad_sad_entry_ipsec_sa_config_traffic_selector_local_ports, yang_name="local-ports", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='start end', extensions=None), is_container='list', yang_name="local-ports", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='list', is_config=True)""",
        })

    self.__local_ports = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_local_ports(self):
    self.__local_ports = YANGDynClass(base=YANGListType("start end",yc_local_ports_ietf_i2nsf_ikeless__ipsec_ikeless_sad_sad_entry_ipsec_sa_config_traffic_selector_local_ports, yang_name="local-ports", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='start end', extensions=None), is_container='list', yang_name="local-ports", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='list', is_config=True)


  def _get_remote_ports(self):
    """
    Getter method for remote_ports, mapped from YANG variable /ipsec_ikeless/sad/sad_entry/ipsec_sa_config/traffic_selector/remote_ports (list)

    YANG Description: List of remote ports. When the upper layer
protocol is ICMP, this 16-bit value represents
code and type.  If this list is not defined,
it is assumed that start and end are 0 by
default (any port).
    """
    return self.__remote_ports
      
  def _set_remote_ports(self, v, load=False):
    """
    Setter method for remote_ports, mapped from YANG variable /ipsec_ikeless/sad/sad_entry/ipsec_sa_config/traffic_selector/remote_ports (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_remote_ports is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_remote_ports() directly.

    YANG Description: List of remote ports. When the upper layer
protocol is ICMP, this 16-bit value represents
code and type.  If this list is not defined,
it is assumed that start and end are 0 by
default (any port).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("start end",yc_remote_ports_ietf_i2nsf_ikeless__ipsec_ikeless_sad_sad_entry_ipsec_sa_config_traffic_selector_remote_ports, yang_name="remote-ports", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='start end', extensions=None), is_container='list', yang_name="remote-ports", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """remote_ports must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("start end",yc_remote_ports_ietf_i2nsf_ikeless__ipsec_ikeless_sad_sad_entry_ipsec_sa_config_traffic_selector_remote_ports, yang_name="remote-ports", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='start end', extensions=None), is_container='list', yang_name="remote-ports", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='list', is_config=True)""",
        })

    self.__remote_ports = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_remote_ports(self):
    self.__remote_ports = YANGDynClass(base=YANGListType("start end",yc_remote_ports_ietf_i2nsf_ikeless__ipsec_ikeless_sad_sad_entry_ipsec_sa_config_traffic_selector_remote_ports, yang_name="remote-ports", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='start end', extensions=None), is_container='list', yang_name="remote-ports", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='list', is_config=True)

  local_prefix = __builtin__.property(_get_local_prefix, _set_local_prefix)
  remote_prefix = __builtin__.property(_get_remote_prefix, _set_remote_prefix)
  inner_protocol = __builtin__.property(_get_inner_protocol, _set_inner_protocol)
  local_ports = __builtin__.property(_get_local_ports, _set_local_ports)
  remote_ports = __builtin__.property(_get_remote_ports, _set_remote_ports)


  _pyangbind_elements = OrderedDict([('local_prefix', local_prefix), ('remote_prefix', remote_prefix), ('inner_protocol', inner_protocol), ('local_ports', local_ports), ('remote_ports', remote_ports), ])


class yc_encryption_ietf_i2nsf_ikeless__ipsec_ikeless_sad_sad_entry_ipsec_sa_config_esp_sa_encryption(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-i2nsf-ikeless - based on the path /ipsec-ikeless/sad/sad-entry/ipsec-sa-config/esp-sa/encryption. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configuration of encryption or
AEAD algorithm for IPsec
Encapsulation Security Payload
(ESP).
  """
  __slots__ = ('_path_helper', '_extmethods', '__encryption_algorithm','__key','__iv',)

  _yang_name = 'encryption'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__encryption_algorithm = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(12), is_leaf=True, yang_name="encryption-algorithm", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='nsfikec:encr-alg-t', is_config=True)
    self.__key = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="key", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='string', is_config=True)
    self.__iv = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="iv", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['ipsec-ikeless', 'sad', 'sad-entry', 'ipsec-sa-config', 'esp-sa', 'encryption']

  def _get_encryption_algorithm(self):
    """
    Getter method for encryption_algorithm, mapped from YANG variable /ipsec_ikeless/sad/sad_entry/ipsec_sa_config/esp_sa/encryption/encryption_algorithm (nsfikec:encr-alg-t)

    YANG Description: Configuration of ESP
encryption.  With AEAD
algorithms, the integrity-algorithm
leaf is not used.
    """
    return self.__encryption_algorithm
      
  def _set_encryption_algorithm(self, v, load=False):
    """
    Setter method for encryption_algorithm, mapped from YANG variable /ipsec_ikeless/sad/sad_entry/ipsec_sa_config/esp_sa/encryption/encryption_algorithm (nsfikec:encr-alg-t)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_encryption_algorithm is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_encryption_algorithm() directly.

    YANG Description: Configuration of ESP
encryption.  With AEAD
algorithms, the integrity-algorithm
leaf is not used.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(12), is_leaf=True, yang_name="encryption-algorithm", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='nsfikec:encr-alg-t', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """encryption_algorithm must be of a type compatible with nsfikec:encr-alg-t""",
          'defined-type': "nsfikec:encr-alg-t",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(12), is_leaf=True, yang_name="encryption-algorithm", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='nsfikec:encr-alg-t', is_config=True)""",
        })

    self.__encryption_algorithm = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_encryption_algorithm(self):
    self.__encryption_algorithm = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(12), is_leaf=True, yang_name="encryption-algorithm", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='nsfikec:encr-alg-t', is_config=True)


  def _get_key(self):
    """
    Getter method for key, mapped from YANG variable /ipsec_ikeless/sad/sad_entry/ipsec_sa_config/esp_sa/encryption/key (string)

    YANG Description: ESP encryption key value.
If this leaf is not defined,
the key is not defined
(e.g., encryption is NULL).
The key length is
determined by the
length of the key set in
this leaf.  By default, it is
128 bits.
    """
    return self.__key
      
  def _set_key(self, v, load=False):
    """
    Setter method for key, mapped from YANG variable /ipsec_ikeless/sad/sad_entry/ipsec_sa_config/esp_sa/encryption/key (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_key is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_key() directly.

    YANG Description: ESP encryption key value.
If this leaf is not defined,
the key is not defined
(e.g., encryption is NULL).
The key length is
determined by the
length of the key set in
this leaf.  By default, it is
128 bits.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="key", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """key must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="key", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='string', is_config=True)""",
        })

    self.__key = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_key(self):
    self.__key = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="key", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='string', is_config=True)


  def _get_iv(self):
    """
    Getter method for iv, mapped from YANG variable /ipsec_ikeless/sad/sad_entry/ipsec_sa_config/esp_sa/encryption/iv (string)

    YANG Description: ESP encryption IV value.  If
this leaf is not defined, the
IV is not defined (e.g.,
encryption is NULL).
    """
    return self.__iv
      
  def _set_iv(self, v, load=False):
    """
    Setter method for iv, mapped from YANG variable /ipsec_ikeless/sad/sad_entry/ipsec_sa_config/esp_sa/encryption/iv (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_iv is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_iv() directly.

    YANG Description: ESP encryption IV value.  If
this leaf is not defined, the
IV is not defined (e.g.,
encryption is NULL).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="iv", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """iv must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="iv", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='string', is_config=True)""",
        })

    self.__iv = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_iv(self):
    self.__iv = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="iv", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='string', is_config=True)

  encryption_algorithm = __builtin__.property(_get_encryption_algorithm, _set_encryption_algorithm)
  key = __builtin__.property(_get_key, _set_key)
  iv = __builtin__.property(_get_iv, _set_iv)


  _pyangbind_elements = OrderedDict([('encryption_algorithm', encryption_algorithm), ('key', key), ('iv', iv), ])


class yc_integrity_ietf_i2nsf_ikeless__ipsec_ikeless_sad_sad_entry_ipsec_sa_config_esp_sa_integrity(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-i2nsf-ikeless - based on the path /ipsec-ikeless/sad/sad-entry/ipsec-sa-config/esp-sa/integrity. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configuration of integrity for
IPsec Encapsulation Security
Payload (ESP).  This container
allows configuration of integrity
algorithms when no AEAD
algorithms are used and
integrity is required.
  """
  __slots__ = ('_path_helper', '_extmethods', '__integrity_algorithm','__key',)

  _yang_name = 'integrity'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__integrity_algorithm = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(12), is_leaf=True, yang_name="integrity-algorithm", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='nsfikec:intr-alg-t', is_config=True)
    self.__key = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="key", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['ipsec-ikeless', 'sad', 'sad-entry', 'ipsec-sa-config', 'esp-sa', 'integrity']

  def _get_integrity_algorithm(self):
    """
    Getter method for integrity_algorithm, mapped from YANG variable /ipsec_ikeless/sad/sad_entry/ipsec_sa_config/esp_sa/integrity/integrity_algorithm (nsfikec:intr-alg-t)

    YANG Description: Message Authentication Code
(MAC) algorithm to provide
integrity in ESP (default
AUTH_HMAC_SHA2_256_128).
With AEAD algorithms,
the integrity leaf is not
used.
    """
    return self.__integrity_algorithm
      
  def _set_integrity_algorithm(self, v, load=False):
    """
    Setter method for integrity_algorithm, mapped from YANG variable /ipsec_ikeless/sad/sad_entry/ipsec_sa_config/esp_sa/integrity/integrity_algorithm (nsfikec:intr-alg-t)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_integrity_algorithm is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_integrity_algorithm() directly.

    YANG Description: Message Authentication Code
(MAC) algorithm to provide
integrity in ESP (default
AUTH_HMAC_SHA2_256_128).
With AEAD algorithms,
the integrity leaf is not
used.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(12), is_leaf=True, yang_name="integrity-algorithm", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='nsfikec:intr-alg-t', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """integrity_algorithm must be of a type compatible with nsfikec:intr-alg-t""",
          'defined-type': "nsfikec:intr-alg-t",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(12), is_leaf=True, yang_name="integrity-algorithm", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='nsfikec:intr-alg-t', is_config=True)""",
        })

    self.__integrity_algorithm = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_integrity_algorithm(self):
    self.__integrity_algorithm = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(12), is_leaf=True, yang_name="integrity-algorithm", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='nsfikec:intr-alg-t', is_config=True)


  def _get_key(self):
    """
    Getter method for key, mapped from YANG variable /ipsec_ikeless/sad/sad_entry/ipsec_sa_config/esp_sa/integrity/key (string)

    YANG Description: ESP integrity key value.
If this leaf is not defined,
the key is not defined (e.g.,
AEAD algorithm is chosen and
integrity algorithm is not
required).  The key length is
determined by the length of
the key configured.
    """
    return self.__key
      
  def _set_key(self, v, load=False):
    """
    Setter method for key, mapped from YANG variable /ipsec_ikeless/sad/sad_entry/ipsec_sa_config/esp_sa/integrity/key (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_key is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_key() directly.

    YANG Description: ESP integrity key value.
If this leaf is not defined,
the key is not defined (e.g.,
AEAD algorithm is chosen and
integrity algorithm is not
required).  The key length is
determined by the length of
the key configured.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="key", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """key must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="key", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='string', is_config=True)""",
        })

    self.__key = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_key(self):
    self.__key = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="key", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='string', is_config=True)

  integrity_algorithm = __builtin__.property(_get_integrity_algorithm, _set_integrity_algorithm)
  key = __builtin__.property(_get_key, _set_key)


  _pyangbind_elements = OrderedDict([('integrity_algorithm', integrity_algorithm), ('key', key), ])


class yc_esp_sa_ietf_i2nsf_ikeless__ipsec_ikeless_sad_sad_entry_ipsec_sa_config_esp_sa(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-i2nsf-ikeless - based on the path /ipsec-ikeless/sad/sad-entry/ipsec-sa-config/esp-sa. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: In case the IPsec SA is an
Encapsulation Security Payload
(ESP), it is required to specify
encryption and integrity
algorithms and key materials.
  """
  __slots__ = ('_path_helper', '_extmethods', '__encryption','__integrity',)

  _yang_name = 'esp-sa'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__encryption = YANGDynClass(base=yc_encryption_ietf_i2nsf_ikeless__ipsec_ikeless_sad_sad_entry_ipsec_sa_config_esp_sa_encryption, is_container='container', yang_name="encryption", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='container', is_config=True)
    self.__integrity = YANGDynClass(base=yc_integrity_ietf_i2nsf_ikeless__ipsec_ikeless_sad_sad_entry_ipsec_sa_config_esp_sa_integrity, is_container='container', yang_name="integrity", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['ipsec-ikeless', 'sad', 'sad-entry', 'ipsec-sa-config', 'esp-sa']

  def _get_encryption(self):
    """
    Getter method for encryption, mapped from YANG variable /ipsec_ikeless/sad/sad_entry/ipsec_sa_config/esp_sa/encryption (container)

    YANG Description: Configuration of encryption or
AEAD algorithm for IPsec
Encapsulation Security Payload
(ESP).
    """
    return self.__encryption
      
  def _set_encryption(self, v, load=False):
    """
    Setter method for encryption, mapped from YANG variable /ipsec_ikeless/sad/sad_entry/ipsec_sa_config/esp_sa/encryption (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_encryption is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_encryption() directly.

    YANG Description: Configuration of encryption or
AEAD algorithm for IPsec
Encapsulation Security Payload
(ESP).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_encryption_ietf_i2nsf_ikeless__ipsec_ikeless_sad_sad_entry_ipsec_sa_config_esp_sa_encryption, is_container='container', yang_name="encryption", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """encryption must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_encryption_ietf_i2nsf_ikeless__ipsec_ikeless_sad_sad_entry_ipsec_sa_config_esp_sa_encryption, is_container='container', yang_name="encryption", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='container', is_config=True)""",
        })

    self.__encryption = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_encryption(self):
    self.__encryption = YANGDynClass(base=yc_encryption_ietf_i2nsf_ikeless__ipsec_ikeless_sad_sad_entry_ipsec_sa_config_esp_sa_encryption, is_container='container', yang_name="encryption", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='container', is_config=True)


  def _get_integrity(self):
    """
    Getter method for integrity, mapped from YANG variable /ipsec_ikeless/sad/sad_entry/ipsec_sa_config/esp_sa/integrity (container)

    YANG Description: Configuration of integrity for
IPsec Encapsulation Security
Payload (ESP).  This container
allows configuration of integrity
algorithms when no AEAD
algorithms are used and
integrity is required.
    """
    return self.__integrity
      
  def _set_integrity(self, v, load=False):
    """
    Setter method for integrity, mapped from YANG variable /ipsec_ikeless/sad/sad_entry/ipsec_sa_config/esp_sa/integrity (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_integrity is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_integrity() directly.

    YANG Description: Configuration of integrity for
IPsec Encapsulation Security
Payload (ESP).  This container
allows configuration of integrity
algorithms when no AEAD
algorithms are used and
integrity is required.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_integrity_ietf_i2nsf_ikeless__ipsec_ikeless_sad_sad_entry_ipsec_sa_config_esp_sa_integrity, is_container='container', yang_name="integrity", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """integrity must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_integrity_ietf_i2nsf_ikeless__ipsec_ikeless_sad_sad_entry_ipsec_sa_config_esp_sa_integrity, is_container='container', yang_name="integrity", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='container', is_config=True)""",
        })

    self.__integrity = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_integrity(self):
    self.__integrity = YANGDynClass(base=yc_integrity_ietf_i2nsf_ikeless__ipsec_ikeless_sad_sad_entry_ipsec_sa_config_esp_sa_integrity, is_container='container', yang_name="integrity", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='container', is_config=True)

  encryption = __builtin__.property(_get_encryption, _set_encryption)
  integrity = __builtin__.property(_get_integrity, _set_integrity)


  _pyangbind_elements = OrderedDict([('encryption', encryption), ('integrity', integrity), ])


class yc_sa_lifetime_hard_ietf_i2nsf_ikeless__ipsec_ikeless_sad_sad_entry_ipsec_sa_config_sa_lifetime_hard(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-i2nsf-ikeless - based on the path /ipsec-ikeless/sad/sad-entry/ipsec-sa-config/sa-lifetime-hard. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: IPsec SA hard lifetime.  The action
associated is terminate and hold.
  """
  __slots__ = ('_path_helper', '_extmethods', '__time','__bytes','__packets','__idle',)

  _yang_name = 'sa-lifetime-hard'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(0), is_leaf=True, yang_name="time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='uint32', is_config=True)
    self.__bytes = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), default=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64)(0), is_leaf=True, yang_name="bytes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='uint64', is_config=True)
    self.__packets = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(0), is_leaf=True, yang_name="packets", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='uint32', is_config=True)
    self.__idle = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(0), is_leaf=True, yang_name="idle", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='uint32', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['ipsec-ikeless', 'sad', 'sad-entry', 'ipsec-sa-config', 'sa-lifetime-hard']

  def _get_time(self):
    """
    Getter method for time, mapped from YANG variable /ipsec_ikeless/sad/sad_entry/ipsec_sa_config/sa_lifetime_hard/time (uint32)

    YANG Description: Time in seconds since the IPsec SA was added.
For example, if this value is 180 seconds, it
means the IPsec SA expires in 180 seconds since
it was added.  The value 0 implies infinite.
    """
    return self.__time
      
  def _set_time(self, v, load=False):
    """
    Setter method for time, mapped from YANG variable /ipsec_ikeless/sad/sad_entry/ipsec_sa_config/sa_lifetime_hard/time (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_time is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_time() directly.

    YANG Description: Time in seconds since the IPsec SA was added.
For example, if this value is 180 seconds, it
means the IPsec SA expires in 180 seconds since
it was added.  The value 0 implies infinite.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(0), is_leaf=True, yang_name="time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """time must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(0), is_leaf=True, yang_name="time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='uint32', is_config=True)""",
        })

    self.__time = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_time(self):
    self.__time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(0), is_leaf=True, yang_name="time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='uint32', is_config=True)


  def _get_bytes(self):
    """
    Getter method for bytes, mapped from YANG variable /ipsec_ikeless/sad/sad_entry/ipsec_sa_config/sa_lifetime_hard/bytes (uint64)

    YANG Description: If the IPsec SA processes the number of bytes
expressed in this leaf, the IPsec SA expires and
SHOULD be rekeyed.  The value 0 implies
infinite.
    """
    return self.__bytes
      
  def _set_bytes(self, v, load=False):
    """
    Setter method for bytes, mapped from YANG variable /ipsec_ikeless/sad/sad_entry/ipsec_sa_config/sa_lifetime_hard/bytes (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_bytes is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_bytes() directly.

    YANG Description: If the IPsec SA processes the number of bytes
expressed in this leaf, the IPsec SA expires and
SHOULD be rekeyed.  The value 0 implies
infinite.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), default=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64)(0), is_leaf=True, yang_name="bytes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='uint64', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """bytes must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), default=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64)(0), is_leaf=True, yang_name="bytes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='uint64', is_config=True)""",
        })

    self.__bytes = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_bytes(self):
    self.__bytes = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), default=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64)(0), is_leaf=True, yang_name="bytes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='uint64', is_config=True)


  def _get_packets(self):
    """
    Getter method for packets, mapped from YANG variable /ipsec_ikeless/sad/sad_entry/ipsec_sa_config/sa_lifetime_hard/packets (uint32)

    YANG Description: If the IPsec SA processes the number of packets
expressed in this leaf, the IPsec SA expires and
SHOULD be rekeyed.  The value 0 implies
infinite.
    """
    return self.__packets
      
  def _set_packets(self, v, load=False):
    """
    Setter method for packets, mapped from YANG variable /ipsec_ikeless/sad/sad_entry/ipsec_sa_config/sa_lifetime_hard/packets (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_packets is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_packets() directly.

    YANG Description: If the IPsec SA processes the number of packets
expressed in this leaf, the IPsec SA expires and
SHOULD be rekeyed.  The value 0 implies
infinite.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(0), is_leaf=True, yang_name="packets", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """packets must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(0), is_leaf=True, yang_name="packets", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='uint32', is_config=True)""",
        })

    self.__packets = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_packets(self):
    self.__packets = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(0), is_leaf=True, yang_name="packets", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='uint32', is_config=True)


  def _get_idle(self):
    """
    Getter method for idle, mapped from YANG variable /ipsec_ikeless/sad/sad_entry/ipsec_sa_config/sa_lifetime_hard/idle (uint32)

    YANG Description: When an NSF stores an IPsec SA, it
consumes system resources.  For an idle IPsec SA, this
is a waste of resources.  If the IPsec SA is idle
during this number of seconds, the IPsec SA
SHOULD be removed.  The value 0 implies
infinite.
    """
    return self.__idle
      
  def _set_idle(self, v, load=False):
    """
    Setter method for idle, mapped from YANG variable /ipsec_ikeless/sad/sad_entry/ipsec_sa_config/sa_lifetime_hard/idle (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_idle is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_idle() directly.

    YANG Description: When an NSF stores an IPsec SA, it
consumes system resources.  For an idle IPsec SA, this
is a waste of resources.  If the IPsec SA is idle
during this number of seconds, the IPsec SA
SHOULD be removed.  The value 0 implies
infinite.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(0), is_leaf=True, yang_name="idle", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """idle must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(0), is_leaf=True, yang_name="idle", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='uint32', is_config=True)""",
        })

    self.__idle = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_idle(self):
    self.__idle = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(0), is_leaf=True, yang_name="idle", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='uint32', is_config=True)

  time = __builtin__.property(_get_time, _set_time)
  bytes = __builtin__.property(_get_bytes, _set_bytes)
  packets = __builtin__.property(_get_packets, _set_packets)
  idle = __builtin__.property(_get_idle, _set_idle)


  _pyangbind_elements = OrderedDict([('time', time), ('bytes', bytes), ('packets', packets), ('idle', idle), ])


class yc_sa_lifetime_soft_ietf_i2nsf_ikeless__ipsec_ikeless_sad_sad_entry_ipsec_sa_config_sa_lifetime_soft(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-i2nsf-ikeless - based on the path /ipsec-ikeless/sad/sad-entry/ipsec-sa-config/sa-lifetime-soft. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: IPsec SA soft lifetime.
  """
  __slots__ = ('_path_helper', '_extmethods', '__time','__bytes','__packets','__idle','__action',)

  _yang_name = 'sa-lifetime-soft'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(0), is_leaf=True, yang_name="time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='uint32', is_config=True)
    self.__bytes = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), default=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64)(0), is_leaf=True, yang_name="bytes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='uint64', is_config=True)
    self.__packets = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(0), is_leaf=True, yang_name="packets", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='uint32', is_config=True)
    self.__idle = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(0), is_leaf=True, yang_name="idle", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='uint32', is_config=True)
    self.__action = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'terminate-clear': {}, 'terminate-hold': {}, 'replace': {}},), is_leaf=True, yang_name="action", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='nsfikec:lifetime-action', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['ipsec-ikeless', 'sad', 'sad-entry', 'ipsec-sa-config', 'sa-lifetime-soft']

  def _get_time(self):
    """
    Getter method for time, mapped from YANG variable /ipsec_ikeless/sad/sad_entry/ipsec_sa_config/sa_lifetime_soft/time (uint32)

    YANG Description: Time in seconds since the IPsec SA was added.
For example, if this value is 180 seconds, it
means the IPsec SA expires in 180 seconds since
it was added.  The value 0 implies infinite.
    """
    return self.__time
      
  def _set_time(self, v, load=False):
    """
    Setter method for time, mapped from YANG variable /ipsec_ikeless/sad/sad_entry/ipsec_sa_config/sa_lifetime_soft/time (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_time is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_time() directly.

    YANG Description: Time in seconds since the IPsec SA was added.
For example, if this value is 180 seconds, it
means the IPsec SA expires in 180 seconds since
it was added.  The value 0 implies infinite.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(0), is_leaf=True, yang_name="time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """time must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(0), is_leaf=True, yang_name="time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='uint32', is_config=True)""",
        })

    self.__time = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_time(self):
    self.__time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(0), is_leaf=True, yang_name="time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='uint32', is_config=True)


  def _get_bytes(self):
    """
    Getter method for bytes, mapped from YANG variable /ipsec_ikeless/sad/sad_entry/ipsec_sa_config/sa_lifetime_soft/bytes (uint64)

    YANG Description: If the IPsec SA processes the number of bytes
expressed in this leaf, the IPsec SA expires and
SHOULD be rekeyed.  The value 0 implies
infinite.
    """
    return self.__bytes
      
  def _set_bytes(self, v, load=False):
    """
    Setter method for bytes, mapped from YANG variable /ipsec_ikeless/sad/sad_entry/ipsec_sa_config/sa_lifetime_soft/bytes (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_bytes is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_bytes() directly.

    YANG Description: If the IPsec SA processes the number of bytes
expressed in this leaf, the IPsec SA expires and
SHOULD be rekeyed.  The value 0 implies
infinite.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), default=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64)(0), is_leaf=True, yang_name="bytes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='uint64', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """bytes must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), default=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64)(0), is_leaf=True, yang_name="bytes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='uint64', is_config=True)""",
        })

    self.__bytes = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_bytes(self):
    self.__bytes = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), default=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64)(0), is_leaf=True, yang_name="bytes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='uint64', is_config=True)


  def _get_packets(self):
    """
    Getter method for packets, mapped from YANG variable /ipsec_ikeless/sad/sad_entry/ipsec_sa_config/sa_lifetime_soft/packets (uint32)

    YANG Description: If the IPsec SA processes the number of packets
expressed in this leaf, the IPsec SA expires and
SHOULD be rekeyed.  The value 0 implies
infinite.
    """
    return self.__packets
      
  def _set_packets(self, v, load=False):
    """
    Setter method for packets, mapped from YANG variable /ipsec_ikeless/sad/sad_entry/ipsec_sa_config/sa_lifetime_soft/packets (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_packets is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_packets() directly.

    YANG Description: If the IPsec SA processes the number of packets
expressed in this leaf, the IPsec SA expires and
SHOULD be rekeyed.  The value 0 implies
infinite.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(0), is_leaf=True, yang_name="packets", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """packets must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(0), is_leaf=True, yang_name="packets", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='uint32', is_config=True)""",
        })

    self.__packets = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_packets(self):
    self.__packets = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(0), is_leaf=True, yang_name="packets", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='uint32', is_config=True)


  def _get_idle(self):
    """
    Getter method for idle, mapped from YANG variable /ipsec_ikeless/sad/sad_entry/ipsec_sa_config/sa_lifetime_soft/idle (uint32)

    YANG Description: When an NSF stores an IPsec SA, it
consumes system resources.  For an idle IPsec SA, this
is a waste of resources.  If the IPsec SA is idle
during this number of seconds, the IPsec SA
SHOULD be removed.  The value 0 implies
infinite.
    """
    return self.__idle
      
  def _set_idle(self, v, load=False):
    """
    Setter method for idle, mapped from YANG variable /ipsec_ikeless/sad/sad_entry/ipsec_sa_config/sa_lifetime_soft/idle (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_idle is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_idle() directly.

    YANG Description: When an NSF stores an IPsec SA, it
consumes system resources.  For an idle IPsec SA, this
is a waste of resources.  If the IPsec SA is idle
during this number of seconds, the IPsec SA
SHOULD be removed.  The value 0 implies
infinite.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(0), is_leaf=True, yang_name="idle", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """idle must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(0), is_leaf=True, yang_name="idle", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='uint32', is_config=True)""",
        })

    self.__idle = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_idle(self):
    self.__idle = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(0), is_leaf=True, yang_name="idle", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='uint32', is_config=True)


  def _get_action(self):
    """
    Getter method for action, mapped from YANG variable /ipsec_ikeless/sad/sad_entry/ipsec_sa_config/sa_lifetime_soft/action (nsfikec:lifetime-action)

    YANG Description: Action lifetime: terminate-clear,
terminate-hold, or replace.
    """
    return self.__action
      
  def _set_action(self, v, load=False):
    """
    Setter method for action, mapped from YANG variable /ipsec_ikeless/sad/sad_entry/ipsec_sa_config/sa_lifetime_soft/action (nsfikec:lifetime-action)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_action is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_action() directly.

    YANG Description: Action lifetime: terminate-clear,
terminate-hold, or replace.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'terminate-clear': {}, 'terminate-hold': {}, 'replace': {}},), is_leaf=True, yang_name="action", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='nsfikec:lifetime-action', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """action must be of a type compatible with nsfikec:lifetime-action""",
          'defined-type': "nsfikec:lifetime-action",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'terminate-clear': {}, 'terminate-hold': {}, 'replace': {}},), is_leaf=True, yang_name="action", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='nsfikec:lifetime-action', is_config=True)""",
        })

    self.__action = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_action(self):
    self.__action = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'terminate-clear': {}, 'terminate-hold': {}, 'replace': {}},), is_leaf=True, yang_name="action", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='nsfikec:lifetime-action', is_config=True)

  time = __builtin__.property(_get_time, _set_time)
  bytes = __builtin__.property(_get_bytes, _set_bytes)
  packets = __builtin__.property(_get_packets, _set_packets)
  idle = __builtin__.property(_get_idle, _set_idle)
  action = __builtin__.property(_get_action, _set_action)


  _pyangbind_elements = OrderedDict([('time', time), ('bytes', bytes), ('packets', packets), ('idle', idle), ('action', action), ])


class yc_dscp_mapping_ietf_i2nsf_ikeless__ipsec_ikeless_sad_sad_entry_ipsec_sa_config_tunnel_dscp_mapping(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-i2nsf-ikeless - based on the path /ipsec-ikeless/sad/sad-entry/ipsec-sa-config/tunnel/dscp-mapping. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: A list that represents an array with the mapping from the
inner DSCP value to outer DSCP value when bypass-dscp is
false.  To express a default mapping in the list where any
other inner dscp value is not matching a node in the list,
a new node has to be included at the end of the list where
the leaf inner-dscp is not defined (ANY) and the leaf
outer-dscp includes the value of the mapping.  If there is
no value set in the leaf outer-dscp, the default value for
this leaf is 0.
  """
  __slots__ = ('_path_helper', '_extmethods', '__id','__inner_dscp','__outer_dscp',)

  _yang_name = 'dscp-mapping'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__id = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='uint8', is_config=True)
    self.__inner_dscp = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..63']}), is_leaf=True, yang_name="inner-dscp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='inet:dscp', is_config=True)
    self.__outer_dscp = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..63']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)(0), is_leaf=True, yang_name="outer-dscp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='inet:dscp', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['ipsec-ikeless', 'sad', 'sad-entry', 'ipsec-sa-config', 'tunnel', 'dscp-mapping']

  def _get_id(self):
    """
    Getter method for id, mapped from YANG variable /ipsec_ikeless/sad/sad_entry/ipsec_sa_config/tunnel/dscp_mapping/id (uint8)

    YANG Description: The index of list with the
different mappings.
    """
    return self.__id
      
  def _set_id(self, v, load=False):
    """
    Setter method for id, mapped from YANG variable /ipsec_ikeless/sad/sad_entry/ipsec_sa_config/tunnel/dscp_mapping/id (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.

    YANG Description: The index of list with the
different mappings.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='uint8', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """id must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='uint8', is_config=True)""",
        })

    self.__id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_id(self):
    self.__id = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='uint8', is_config=True)


  def _get_inner_dscp(self):
    """
    Getter method for inner_dscp, mapped from YANG variable /ipsec_ikeless/sad/sad_entry/ipsec_sa_config/tunnel/dscp_mapping/inner_dscp (inet:dscp)

    YANG Description: The DSCP value of the inner IP packet.  If this
leaf is not defined, it means ANY inner DSCP value.
    """
    return self.__inner_dscp
      
  def _set_inner_dscp(self, v, load=False):
    """
    Setter method for inner_dscp, mapped from YANG variable /ipsec_ikeless/sad/sad_entry/ipsec_sa_config/tunnel/dscp_mapping/inner_dscp (inet:dscp)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_inner_dscp is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_inner_dscp() directly.

    YANG Description: The DSCP value of the inner IP packet.  If this
leaf is not defined, it means ANY inner DSCP value.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..63']}), is_leaf=True, yang_name="inner-dscp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='inet:dscp', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """inner_dscp must be of a type compatible with inet:dscp""",
          'defined-type': "inet:dscp",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..63']}), is_leaf=True, yang_name="inner-dscp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='inet:dscp', is_config=True)""",
        })

    self.__inner_dscp = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_inner_dscp(self):
    self.__inner_dscp = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..63']}), is_leaf=True, yang_name="inner-dscp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='inet:dscp', is_config=True)


  def _get_outer_dscp(self):
    """
    Getter method for outer_dscp, mapped from YANG variable /ipsec_ikeless/sad/sad_entry/ipsec_sa_config/tunnel/dscp_mapping/outer_dscp (inet:dscp)

    YANG Description: The DSCP value of the outer IP packet.
    """
    return self.__outer_dscp
      
  def _set_outer_dscp(self, v, load=False):
    """
    Setter method for outer_dscp, mapped from YANG variable /ipsec_ikeless/sad/sad_entry/ipsec_sa_config/tunnel/dscp_mapping/outer_dscp (inet:dscp)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_outer_dscp is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_outer_dscp() directly.

    YANG Description: The DSCP value of the outer IP packet.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..63']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)(0), is_leaf=True, yang_name="outer-dscp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='inet:dscp', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """outer_dscp must be of a type compatible with inet:dscp""",
          'defined-type': "inet:dscp",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..63']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)(0), is_leaf=True, yang_name="outer-dscp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='inet:dscp', is_config=True)""",
        })

    self.__outer_dscp = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_outer_dscp(self):
    self.__outer_dscp = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..63']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)(0), is_leaf=True, yang_name="outer-dscp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='inet:dscp', is_config=True)

  id = __builtin__.property(_get_id, _set_id)
  inner_dscp = __builtin__.property(_get_inner_dscp, _set_inner_dscp)
  outer_dscp = __builtin__.property(_get_outer_dscp, _set_outer_dscp)


  _pyangbind_elements = OrderedDict([('id', id), ('inner_dscp', inner_dscp), ('outer_dscp', outer_dscp), ])


class yc_tunnel_ietf_i2nsf_ikeless__ipsec_ikeless_sad_sad_entry_ipsec_sa_config_tunnel(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-i2nsf-ikeless - based on the path /ipsec-ikeless/sad/sad-entry/ipsec-sa-config/tunnel. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Endpoints of the IPsec tunnel.
  """
  __slots__ = ('_path_helper', '_extmethods', '__local_','__remote','__df_bit','__bypass_dscp','__dscp_mapping','__dscp_values',)

  _yang_name = 'tunnel'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__local_ = YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="local", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='inet:ip-address', is_config=True)
    self.__remote = YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="remote", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='inet:ip-address', is_config=True)
    self.__df_bit = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'clear': {}, 'set': {}, 'copy': {}},), default=six.text_type("clear"), is_leaf=True, yang_name="df-bit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='enumeration', is_config=True)
    self.__bypass_dscp = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="bypass-dscp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='boolean', is_config=True)
    self.__dscp_mapping = YANGDynClass(base=YANGListType("id",yc_dscp_mapping_ietf_i2nsf_ikeless__ipsec_ikeless_sad_sad_entry_ipsec_sa_config_tunnel_dscp_mapping, yang_name="dscp-mapping", parent=self, is_container='list', user_ordered=True, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="dscp-mapping", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='list', is_config=True)
    self.__dscp_values = YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..63']})), is_leaf=False, yang_name="dscp-values", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='inet:dscp', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['ipsec-ikeless', 'sad', 'sad-entry', 'ipsec-sa-config', 'tunnel']

  def _get_local_(self):
    """
    Getter method for local_, mapped from YANG variable /ipsec_ikeless/sad/sad_entry/ipsec_sa_config/tunnel/local (inet:ip-address)

    YANG Description: Local IP address' tunnel endpoint.
    """
    return self.__local_
      
  def _set_local_(self, v, load=False):
    """
    Setter method for local_, mapped from YANG variable /ipsec_ikeless/sad/sad_entry/ipsec_sa_config/tunnel/local (inet:ip-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_local_ is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_local_() directly.

    YANG Description: Local IP address' tunnel endpoint.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="local", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='inet:ip-address', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """local_ must be of a type compatible with inet:ip-address""",
          'defined-type': "inet:ip-address",
          'generated-type': """YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="local", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='inet:ip-address', is_config=True)""",
        })

    self.__local_ = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_local_(self):
    self.__local_ = YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="local", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='inet:ip-address', is_config=True)


  def _get_remote(self):
    """
    Getter method for remote, mapped from YANG variable /ipsec_ikeless/sad/sad_entry/ipsec_sa_config/tunnel/remote (inet:ip-address)

    YANG Description: Remote IP address' tunnel endpoint.
    """
    return self.__remote
      
  def _set_remote(self, v, load=False):
    """
    Setter method for remote, mapped from YANG variable /ipsec_ikeless/sad/sad_entry/ipsec_sa_config/tunnel/remote (inet:ip-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_remote is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_remote() directly.

    YANG Description: Remote IP address' tunnel endpoint.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="remote", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='inet:ip-address', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """remote must be of a type compatible with inet:ip-address""",
          'defined-type': "inet:ip-address",
          'generated-type': """YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="remote", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='inet:ip-address', is_config=True)""",
        })

    self.__remote = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_remote(self):
    self.__remote = YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="remote", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='inet:ip-address', is_config=True)


  def _get_df_bit(self):
    """
    Getter method for df_bit, mapped from YANG variable /ipsec_ikeless/sad/sad_entry/ipsec_sa_config/tunnel/df_bit (enumeration)

    YANG Description: Allow configuring the DF bit when encapsulating
tunnel mode IPsec traffic.  RFC 4301 describes
three options to handle the DF bit during
tunnel encapsulation: clear, set, and copy from
the inner IP header.  This MUST be ignored or
has no meaning when the local/remote
IP addresses are IPv6 addresses.
    """
    return self.__df_bit
      
  def _set_df_bit(self, v, load=False):
    """
    Setter method for df_bit, mapped from YANG variable /ipsec_ikeless/sad/sad_entry/ipsec_sa_config/tunnel/df_bit (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_df_bit is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_df_bit() directly.

    YANG Description: Allow configuring the DF bit when encapsulating
tunnel mode IPsec traffic.  RFC 4301 describes
three options to handle the DF bit during
tunnel encapsulation: clear, set, and copy from
the inner IP header.  This MUST be ignored or
has no meaning when the local/remote
IP addresses are IPv6 addresses.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'clear': {}, 'set': {}, 'copy': {}},), default=six.text_type("clear"), is_leaf=True, yang_name="df-bit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='enumeration', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """df_bit must be of a type compatible with enumeration""",
          'defined-type': "ietf-i2nsf-ikeless:enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'clear': {}, 'set': {}, 'copy': {}},), default=six.text_type("clear"), is_leaf=True, yang_name="df-bit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='enumeration', is_config=True)""",
        })

    self.__df_bit = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_df_bit(self):
    self.__df_bit = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'clear': {}, 'set': {}, 'copy': {}},), default=six.text_type("clear"), is_leaf=True, yang_name="df-bit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='enumeration', is_config=True)


  def _get_bypass_dscp(self):
    """
    Getter method for bypass_dscp, mapped from YANG variable /ipsec_ikeless/sad/sad_entry/ipsec_sa_config/tunnel/bypass_dscp (boolean)

    YANG Description: If true, to copy the Differentiated Services Code
Point (DSCP) value from inner header to outer header.
If false, to map DSCP values
from an inner header to values in an outer header
following ../dscp-mapping.
    """
    return self.__bypass_dscp
      
  def _set_bypass_dscp(self, v, load=False):
    """
    Setter method for bypass_dscp, mapped from YANG variable /ipsec_ikeless/sad/sad_entry/ipsec_sa_config/tunnel/bypass_dscp (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_bypass_dscp is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_bypass_dscp() directly.

    YANG Description: If true, to copy the Differentiated Services Code
Point (DSCP) value from inner header to outer header.
If false, to map DSCP values
from an inner header to values in an outer header
following ../dscp-mapping.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="bypass-dscp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """bypass_dscp must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="bypass-dscp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='boolean', is_config=True)""",
        })

    self.__bypass_dscp = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_bypass_dscp(self):
    self.__bypass_dscp = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="bypass-dscp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='boolean', is_config=True)


  def _get_dscp_mapping(self):
    """
    Getter method for dscp_mapping, mapped from YANG variable /ipsec_ikeless/sad/sad_entry/ipsec_sa_config/tunnel/dscp_mapping (list)

    YANG Description: A list that represents an array with the mapping from the
inner DSCP value to outer DSCP value when bypass-dscp is
false.  To express a default mapping in the list where any
other inner dscp value is not matching a node in the list,
a new node has to be included at the end of the list where
the leaf inner-dscp is not defined (ANY) and the leaf
outer-dscp includes the value of the mapping.  If there is
no value set in the leaf outer-dscp, the default value for
this leaf is 0.
    """
    return self.__dscp_mapping
      
  def _set_dscp_mapping(self, v, load=False):
    """
    Setter method for dscp_mapping, mapped from YANG variable /ipsec_ikeless/sad/sad_entry/ipsec_sa_config/tunnel/dscp_mapping (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dscp_mapping is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dscp_mapping() directly.

    YANG Description: A list that represents an array with the mapping from the
inner DSCP value to outer DSCP value when bypass-dscp is
false.  To express a default mapping in the list where any
other inner dscp value is not matching a node in the list,
a new node has to be included at the end of the list where
the leaf inner-dscp is not defined (ANY) and the leaf
outer-dscp includes the value of the mapping.  If there is
no value set in the leaf outer-dscp, the default value for
this leaf is 0.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("id",yc_dscp_mapping_ietf_i2nsf_ikeless__ipsec_ikeless_sad_sad_entry_ipsec_sa_config_tunnel_dscp_mapping, yang_name="dscp-mapping", parent=self, is_container='list', user_ordered=True, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="dscp-mapping", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """dscp_mapping must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("id",yc_dscp_mapping_ietf_i2nsf_ikeless__ipsec_ikeless_sad_sad_entry_ipsec_sa_config_tunnel_dscp_mapping, yang_name="dscp-mapping", parent=self, is_container='list', user_ordered=True, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="dscp-mapping", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='list', is_config=True)""",
        })

    self.__dscp_mapping = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_dscp_mapping(self):
    self.__dscp_mapping = YANGDynClass(base=YANGListType("id",yc_dscp_mapping_ietf_i2nsf_ikeless__ipsec_ikeless_sad_sad_entry_ipsec_sa_config_tunnel_dscp_mapping, yang_name="dscp-mapping", parent=self, is_container='list', user_ordered=True, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="dscp-mapping", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='list', is_config=True)


  def _get_dscp_values(self):
    """
    Getter method for dscp_values, mapped from YANG variable /ipsec_ikeless/sad/sad_entry/ipsec_sa_config/tunnel/dscp_values (inet:dscp)

    YANG Description: DSCP values allowed for ingress packets carried
over this IPsec SA.  If no values are specified, no
DSCP-specific filtering is applied.  When
../bypass-dscp is false and a dscp-mapping is
defined, each value here would be the same as the
'inner' DSCP value for the DSCP mapping (list
dscp-mapping).
    """
    return self.__dscp_values
      
  def _set_dscp_values(self, v, load=False):
    """
    Setter method for dscp_values, mapped from YANG variable /ipsec_ikeless/sad/sad_entry/ipsec_sa_config/tunnel/dscp_values (inet:dscp)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dscp_values is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dscp_values() directly.

    YANG Description: DSCP values allowed for ingress packets carried
over this IPsec SA.  If no values are specified, no
DSCP-specific filtering is applied.  When
../bypass-dscp is false and a dscp-mapping is
defined, each value here would be the same as the
'inner' DSCP value for the DSCP mapping (list
dscp-mapping).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..63']})), is_leaf=False, yang_name="dscp-values", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='inet:dscp', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """dscp_values must be of a type compatible with inet:dscp""",
          'defined-type': "inet:dscp",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..63']})), is_leaf=False, yang_name="dscp-values", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='inet:dscp', is_config=True)""",
        })

    self.__dscp_values = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_dscp_values(self):
    self.__dscp_values = YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..63']})), is_leaf=False, yang_name="dscp-values", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='inet:dscp', is_config=True)

  local_ = __builtin__.property(_get_local_, _set_local_)
  remote = __builtin__.property(_get_remote, _set_remote)
  df_bit = __builtin__.property(_get_df_bit, _set_df_bit)
  bypass_dscp = __builtin__.property(_get_bypass_dscp, _set_bypass_dscp)
  dscp_mapping = __builtin__.property(_get_dscp_mapping, _set_dscp_mapping)
  dscp_values = __builtin__.property(_get_dscp_values, _set_dscp_values)


  _pyangbind_elements = OrderedDict([('local_', local_), ('remote', remote), ('df_bit', df_bit), ('bypass_dscp', bypass_dscp), ('dscp_mapping', dscp_mapping), ('dscp_values', dscp_values), ])


class yc_encapsulation_type_ietf_i2nsf_ikeless__ipsec_ikeless_sad_sad_entry_ipsec_sa_config_encapsulation_type(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-i2nsf-ikeless - based on the path /ipsec-ikeless/sad/sad-entry/ipsec-sa-config/encapsulation-type. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This container carries
configuration information about
the source and destination ports
that will be used for ESP
encapsulation of ESP packets and
the type of encapsulation when NAT
traversal is in place.
  """
  __slots__ = ('_path_helper', '_extmethods', '__espencap','__sport','__dport','__oaddr',)

  _yang_name = 'encapsulation-type'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__espencap = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'espintcp': {}, 'espinudp': {}, 'none': {}},), default=six.text_type("none"), is_leaf=True, yang_name="espencap", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='esp-encap', is_config=True)
    self.__sport = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..65535']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(4500), is_leaf=True, yang_name="sport", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='inet:port-number', is_config=True)
    self.__dport = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..65535']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(4500), is_leaf=True, yang_name="dport", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='inet:port-number', is_config=True)
    self.__oaddr = YANGDynClass(unique=True, base=TypedListType(allowed_type=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),]), is_leaf=False, yang_name="oaddr", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='inet:ip-address', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['ipsec-ikeless', 'sad', 'sad-entry', 'ipsec-sa-config', 'encapsulation-type']

  def _get_espencap(self):
    """
    Getter method for espencap, mapped from YANG variable /ipsec_ikeless/sad/sad_entry/ipsec_sa_config/encapsulation_type/espencap (esp-encap)

    YANG Description: ESP in TCP, ESP in UDP, or ESP in TLS.
    """
    return self.__espencap
      
  def _set_espencap(self, v, load=False):
    """
    Setter method for espencap, mapped from YANG variable /ipsec_ikeless/sad/sad_entry/ipsec_sa_config/encapsulation_type/espencap (esp-encap)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_espencap is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_espencap() directly.

    YANG Description: ESP in TCP, ESP in UDP, or ESP in TLS.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'espintcp': {}, 'espinudp': {}, 'none': {}},), default=six.text_type("none"), is_leaf=True, yang_name="espencap", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='esp-encap', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """espencap must be of a type compatible with esp-encap""",
          'defined-type': "ietf-i2nsf-ikeless:esp-encap",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'espintcp': {}, 'espinudp': {}, 'none': {}},), default=six.text_type("none"), is_leaf=True, yang_name="espencap", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='esp-encap', is_config=True)""",
        })

    self.__espencap = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_espencap(self):
    self.__espencap = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'espintcp': {}, 'espinudp': {}, 'none': {}},), default=six.text_type("none"), is_leaf=True, yang_name="espencap", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='esp-encap', is_config=True)


  def _get_sport(self):
    """
    Getter method for sport, mapped from YANG variable /ipsec_ikeless/sad/sad_entry/ipsec_sa_config/encapsulation_type/sport (inet:port-number)

    YANG Description: Encapsulation source port.
    """
    return self.__sport
      
  def _set_sport(self, v, load=False):
    """
    Setter method for sport, mapped from YANG variable /ipsec_ikeless/sad/sad_entry/ipsec_sa_config/encapsulation_type/sport (inet:port-number)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_sport is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_sport() directly.

    YANG Description: Encapsulation source port.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..65535']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(4500), is_leaf=True, yang_name="sport", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='inet:port-number', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """sport must be of a type compatible with inet:port-number""",
          'defined-type': "inet:port-number",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..65535']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(4500), is_leaf=True, yang_name="sport", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='inet:port-number', is_config=True)""",
        })

    self.__sport = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_sport(self):
    self.__sport = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..65535']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(4500), is_leaf=True, yang_name="sport", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='inet:port-number', is_config=True)


  def _get_dport(self):
    """
    Getter method for dport, mapped from YANG variable /ipsec_ikeless/sad/sad_entry/ipsec_sa_config/encapsulation_type/dport (inet:port-number)

    YANG Description: Encapsulation destination port.
    """
    return self.__dport
      
  def _set_dport(self, v, load=False):
    """
    Setter method for dport, mapped from YANG variable /ipsec_ikeless/sad/sad_entry/ipsec_sa_config/encapsulation_type/dport (inet:port-number)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dport is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dport() directly.

    YANG Description: Encapsulation destination port.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..65535']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(4500), is_leaf=True, yang_name="dport", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='inet:port-number', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """dport must be of a type compatible with inet:port-number""",
          'defined-type': "inet:port-number",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..65535']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(4500), is_leaf=True, yang_name="dport", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='inet:port-number', is_config=True)""",
        })

    self.__dport = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_dport(self):
    self.__dport = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..65535']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(4500), is_leaf=True, yang_name="dport", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='inet:port-number', is_config=True)


  def _get_oaddr(self):
    """
    Getter method for oaddr, mapped from YANG variable /ipsec_ikeless/sad/sad_entry/ipsec_sa_config/encapsulation_type/oaddr (inet:ip-address)

    YANG Description: If required, this is the original address that
was used before NAT was applied over the packet.
    """
    return self.__oaddr
      
  def _set_oaddr(self, v, load=False):
    """
    Setter method for oaddr, mapped from YANG variable /ipsec_ikeless/sad/sad_entry/ipsec_sa_config/encapsulation_type/oaddr (inet:ip-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_oaddr is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_oaddr() directly.

    YANG Description: If required, this is the original address that
was used before NAT was applied over the packet.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),]), is_leaf=False, yang_name="oaddr", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='inet:ip-address', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """oaddr must be of a type compatible with inet:ip-address""",
          'defined-type': "inet:ip-address",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),]), is_leaf=False, yang_name="oaddr", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='inet:ip-address', is_config=True)""",
        })

    self.__oaddr = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_oaddr(self):
    self.__oaddr = YANGDynClass(unique=True, base=TypedListType(allowed_type=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),]), is_leaf=False, yang_name="oaddr", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='inet:ip-address', is_config=True)

  espencap = __builtin__.property(_get_espencap, _set_espencap)
  sport = __builtin__.property(_get_sport, _set_sport)
  dport = __builtin__.property(_get_dport, _set_dport)
  oaddr = __builtin__.property(_get_oaddr, _set_oaddr)


  _pyangbind_elements = OrderedDict([('espencap', espencap), ('sport', sport), ('dport', dport), ('oaddr', oaddr), ])


class yc_ipsec_sa_config_ietf_i2nsf_ikeless__ipsec_ikeless_sad_sad_entry_ipsec_sa_config(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-i2nsf-ikeless - based on the path /ipsec-ikeless/sad/sad-entry/ipsec-sa-config. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This container allows configuring
details of an IPsec SA.
  """
  __slots__ = ('_path_helper', '_extmethods', '__spi','__ext_seq_num','__seq_overflow','__anti_replay_window_size','__traffic_selector','__protocol_parameters','__mode','__esp_sa','__sa_lifetime_hard','__sa_lifetime_soft','__tunnel','__encapsulation_type',)

  _yang_name = 'ipsec-sa-config'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__spi = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..max']}), is_leaf=True, yang_name="spi", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='uint32', is_config=True)
    self.__ext_seq_num = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="ext-seq-num", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='boolean', is_config=True)
    self.__seq_overflow = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="seq-overflow", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='boolean', is_config=True)
    self.__anti_replay_window_size = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(64), is_leaf=True, yang_name="anti-replay-window-size", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='uint32', is_config=True)
    self.__traffic_selector = YANGDynClass(base=yc_traffic_selector_ietf_i2nsf_ikeless__ipsec_ikeless_sad_sad_entry_ipsec_sa_config_traffic_selector, is_container='container', yang_name="traffic-selector", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='container', is_config=True)
    self.__protocol_parameters = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'esp': {}},), default=six.text_type("esp"), is_leaf=True, yang_name="protocol-parameters", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='nsfikec:ipsec-protocol-params', is_config=True)
    self.__mode = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'transport': {}, 'tunnel': {}},), default=six.text_type("transport"), is_leaf=True, yang_name="mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='nsfikec:ipsec-mode', is_config=True)
    self.__esp_sa = YANGDynClass(base=yc_esp_sa_ietf_i2nsf_ikeless__ipsec_ikeless_sad_sad_entry_ipsec_sa_config_esp_sa, is_container='container', yang_name="esp-sa", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='container', is_config=True)
    self.__sa_lifetime_hard = YANGDynClass(base=yc_sa_lifetime_hard_ietf_i2nsf_ikeless__ipsec_ikeless_sad_sad_entry_ipsec_sa_config_sa_lifetime_hard, is_container='container', yang_name="sa-lifetime-hard", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='container', is_config=True)
    self.__sa_lifetime_soft = YANGDynClass(base=yc_sa_lifetime_soft_ietf_i2nsf_ikeless__ipsec_ikeless_sad_sad_entry_ipsec_sa_config_sa_lifetime_soft, is_container='container', yang_name="sa-lifetime-soft", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='container', is_config=True)
    self.__tunnel = YANGDynClass(base=yc_tunnel_ietf_i2nsf_ikeless__ipsec_ikeless_sad_sad_entry_ipsec_sa_config_tunnel, is_container='container', yang_name="tunnel", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='container', is_config=True)
    self.__encapsulation_type = YANGDynClass(base=yc_encapsulation_type_ietf_i2nsf_ikeless__ipsec_ikeless_sad_sad_entry_ipsec_sa_config_encapsulation_type, is_container='container', yang_name="encapsulation-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['ipsec-ikeless', 'sad', 'sad-entry', 'ipsec-sa-config']

  def _get_spi(self):
    """
    Getter method for spi, mapped from YANG variable /ipsec_ikeless/sad/sad_entry/ipsec_sa_config/spi (uint32)

    YANG Description: IPsec SA of Security Parameter Index (SPI).
    """
    return self.__spi
      
  def _set_spi(self, v, load=False):
    """
    Setter method for spi, mapped from YANG variable /ipsec_ikeless/sad/sad_entry/ipsec_sa_config/spi (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_spi is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_spi() directly.

    YANG Description: IPsec SA of Security Parameter Index (SPI).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..max']}), is_leaf=True, yang_name="spi", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """spi must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..max']}), is_leaf=True, yang_name="spi", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='uint32', is_config=True)""",
        })

    self.__spi = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_spi(self):
    self.__spi = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..max']}), is_leaf=True, yang_name="spi", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='uint32', is_config=True)


  def _get_ext_seq_num(self):
    """
    Getter method for ext_seq_num, mapped from YANG variable /ipsec_ikeless/sad/sad_entry/ipsec_sa_config/ext_seq_num (boolean)

    YANG Description: True if this IPsec SA is using extended
sequence numbers.  If true, the 64-bit
extended sequence number counter is used;
if false, the normal 32-bit sequence
number counter is used.
    """
    return self.__ext_seq_num
      
  def _set_ext_seq_num(self, v, load=False):
    """
    Setter method for ext_seq_num, mapped from YANG variable /ipsec_ikeless/sad/sad_entry/ipsec_sa_config/ext_seq_num (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ext_seq_num is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ext_seq_num() directly.

    YANG Description: True if this IPsec SA is using extended
sequence numbers.  If true, the 64-bit
extended sequence number counter is used;
if false, the normal 32-bit sequence
number counter is used.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="ext-seq-num", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ext_seq_num must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="ext-seq-num", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='boolean', is_config=True)""",
        })

    self.__ext_seq_num = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ext_seq_num(self):
    self.__ext_seq_num = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="ext-seq-num", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='boolean', is_config=True)


  def _get_seq_overflow(self):
    """
    Getter method for seq_overflow, mapped from YANG variable /ipsec_ikeless/sad/sad_entry/ipsec_sa_config/seq_overflow (boolean)

    YANG Description: The flag indicating whether
overflow of the sequence number
counter should prevent transmission
of additional packets on the IPsec
SA (false) and, therefore, needs to
be rekeyed or whether rollover is
permitted (true).  If Authenticated
Encryption with Associated Data
(AEAD) is used (leaf
esp-algorithms/encryption/algorithm-type),
this flag MUST BE false. Setting this
flag to true is strongly discouraged.
    """
    return self.__seq_overflow
      
  def _set_seq_overflow(self, v, load=False):
    """
    Setter method for seq_overflow, mapped from YANG variable /ipsec_ikeless/sad/sad_entry/ipsec_sa_config/seq_overflow (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_seq_overflow is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_seq_overflow() directly.

    YANG Description: The flag indicating whether
overflow of the sequence number
counter should prevent transmission
of additional packets on the IPsec
SA (false) and, therefore, needs to
be rekeyed or whether rollover is
permitted (true).  If Authenticated
Encryption with Associated Data
(AEAD) is used (leaf
esp-algorithms/encryption/algorithm-type),
this flag MUST BE false. Setting this
flag to true is strongly discouraged.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="seq-overflow", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """seq_overflow must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="seq-overflow", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='boolean', is_config=True)""",
        })

    self.__seq_overflow = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_seq_overflow(self):
    self.__seq_overflow = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="seq-overflow", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='boolean', is_config=True)


  def _get_anti_replay_window_size(self):
    """
    Getter method for anti_replay_window_size, mapped from YANG variable /ipsec_ikeless/sad/sad_entry/ipsec_sa_config/anti_replay_window_size (uint32)

    YANG Description: To set the anti-replay window size.
The default value is set to 64,
following the recommendation in RFC 4303.
    """
    return self.__anti_replay_window_size
      
  def _set_anti_replay_window_size(self, v, load=False):
    """
    Setter method for anti_replay_window_size, mapped from YANG variable /ipsec_ikeless/sad/sad_entry/ipsec_sa_config/anti_replay_window_size (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_anti_replay_window_size is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_anti_replay_window_size() directly.

    YANG Description: To set the anti-replay window size.
The default value is set to 64,
following the recommendation in RFC 4303.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(64), is_leaf=True, yang_name="anti-replay-window-size", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """anti_replay_window_size must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(64), is_leaf=True, yang_name="anti-replay-window-size", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='uint32', is_config=True)""",
        })

    self.__anti_replay_window_size = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_anti_replay_window_size(self):
    self.__anti_replay_window_size = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(64), is_leaf=True, yang_name="anti-replay-window-size", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='uint32', is_config=True)


  def _get_traffic_selector(self):
    """
    Getter method for traffic_selector, mapped from YANG variable /ipsec_ikeless/sad/sad_entry/ipsec_sa_config/traffic_selector (container)

    YANG Description: The IPsec SA Traffic Selector.
    """
    return self.__traffic_selector
      
  def _set_traffic_selector(self, v, load=False):
    """
    Setter method for traffic_selector, mapped from YANG variable /ipsec_ikeless/sad/sad_entry/ipsec_sa_config/traffic_selector (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_traffic_selector is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_traffic_selector() directly.

    YANG Description: The IPsec SA Traffic Selector.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_traffic_selector_ietf_i2nsf_ikeless__ipsec_ikeless_sad_sad_entry_ipsec_sa_config_traffic_selector, is_container='container', yang_name="traffic-selector", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """traffic_selector must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_traffic_selector_ietf_i2nsf_ikeless__ipsec_ikeless_sad_sad_entry_ipsec_sa_config_traffic_selector, is_container='container', yang_name="traffic-selector", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='container', is_config=True)""",
        })

    self.__traffic_selector = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_traffic_selector(self):
    self.__traffic_selector = YANGDynClass(base=yc_traffic_selector_ietf_i2nsf_ikeless__ipsec_ikeless_sad_sad_entry_ipsec_sa_config_traffic_selector, is_container='container', yang_name="traffic-selector", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='container', is_config=True)


  def _get_protocol_parameters(self):
    """
    Getter method for protocol_parameters, mapped from YANG variable /ipsec_ikeless/sad/sad_entry/ipsec_sa_config/protocol_parameters (nsfikec:ipsec-protocol-params)

    YANG Description: Security protocol of IPsec SA, only
ESP so far.
    """
    return self.__protocol_parameters
      
  def _set_protocol_parameters(self, v, load=False):
    """
    Setter method for protocol_parameters, mapped from YANG variable /ipsec_ikeless/sad/sad_entry/ipsec_sa_config/protocol_parameters (nsfikec:ipsec-protocol-params)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_protocol_parameters is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_protocol_parameters() directly.

    YANG Description: Security protocol of IPsec SA, only
ESP so far.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'esp': {}},), default=six.text_type("esp"), is_leaf=True, yang_name="protocol-parameters", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='nsfikec:ipsec-protocol-params', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """protocol_parameters must be of a type compatible with nsfikec:ipsec-protocol-params""",
          'defined-type': "nsfikec:ipsec-protocol-params",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'esp': {}},), default=six.text_type("esp"), is_leaf=True, yang_name="protocol-parameters", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='nsfikec:ipsec-protocol-params', is_config=True)""",
        })

    self.__protocol_parameters = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_protocol_parameters(self):
    self.__protocol_parameters = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'esp': {}},), default=six.text_type("esp"), is_leaf=True, yang_name="protocol-parameters", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='nsfikec:ipsec-protocol-params', is_config=True)


  def _get_mode(self):
    """
    Getter method for mode, mapped from YANG variable /ipsec_ikeless/sad/sad_entry/ipsec_sa_config/mode (nsfikec:ipsec-mode)

    YANG Description: Tunnel or transport mode.
    """
    return self.__mode
      
  def _set_mode(self, v, load=False):
    """
    Setter method for mode, mapped from YANG variable /ipsec_ikeless/sad/sad_entry/ipsec_sa_config/mode (nsfikec:ipsec-mode)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mode is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mode() directly.

    YANG Description: Tunnel or transport mode.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'transport': {}, 'tunnel': {}},), default=six.text_type("transport"), is_leaf=True, yang_name="mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='nsfikec:ipsec-mode', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mode must be of a type compatible with nsfikec:ipsec-mode""",
          'defined-type': "nsfikec:ipsec-mode",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'transport': {}, 'tunnel': {}},), default=six.text_type("transport"), is_leaf=True, yang_name="mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='nsfikec:ipsec-mode', is_config=True)""",
        })

    self.__mode = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mode(self):
    self.__mode = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'transport': {}, 'tunnel': {}},), default=six.text_type("transport"), is_leaf=True, yang_name="mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='nsfikec:ipsec-mode', is_config=True)


  def _get_esp_sa(self):
    """
    Getter method for esp_sa, mapped from YANG variable /ipsec_ikeless/sad/sad_entry/ipsec_sa_config/esp_sa (container)

    YANG Description: In case the IPsec SA is an
Encapsulation Security Payload
(ESP), it is required to specify
encryption and integrity
algorithms and key materials.
    """
    return self.__esp_sa
      
  def _set_esp_sa(self, v, load=False):
    """
    Setter method for esp_sa, mapped from YANG variable /ipsec_ikeless/sad/sad_entry/ipsec_sa_config/esp_sa (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_esp_sa is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_esp_sa() directly.

    YANG Description: In case the IPsec SA is an
Encapsulation Security Payload
(ESP), it is required to specify
encryption and integrity
algorithms and key materials.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_esp_sa_ietf_i2nsf_ikeless__ipsec_ikeless_sad_sad_entry_ipsec_sa_config_esp_sa, is_container='container', yang_name="esp-sa", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """esp_sa must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_esp_sa_ietf_i2nsf_ikeless__ipsec_ikeless_sad_sad_entry_ipsec_sa_config_esp_sa, is_container='container', yang_name="esp-sa", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='container', is_config=True)""",
        })

    self.__esp_sa = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_esp_sa(self):
    self.__esp_sa = YANGDynClass(base=yc_esp_sa_ietf_i2nsf_ikeless__ipsec_ikeless_sad_sad_entry_ipsec_sa_config_esp_sa, is_container='container', yang_name="esp-sa", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='container', is_config=True)


  def _get_sa_lifetime_hard(self):
    """
    Getter method for sa_lifetime_hard, mapped from YANG variable /ipsec_ikeless/sad/sad_entry/ipsec_sa_config/sa_lifetime_hard (container)

    YANG Description: IPsec SA hard lifetime.  The action
associated is terminate and hold.
    """
    return self.__sa_lifetime_hard
      
  def _set_sa_lifetime_hard(self, v, load=False):
    """
    Setter method for sa_lifetime_hard, mapped from YANG variable /ipsec_ikeless/sad/sad_entry/ipsec_sa_config/sa_lifetime_hard (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_sa_lifetime_hard is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_sa_lifetime_hard() directly.

    YANG Description: IPsec SA hard lifetime.  The action
associated is terminate and hold.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_sa_lifetime_hard_ietf_i2nsf_ikeless__ipsec_ikeless_sad_sad_entry_ipsec_sa_config_sa_lifetime_hard, is_container='container', yang_name="sa-lifetime-hard", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """sa_lifetime_hard must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_sa_lifetime_hard_ietf_i2nsf_ikeless__ipsec_ikeless_sad_sad_entry_ipsec_sa_config_sa_lifetime_hard, is_container='container', yang_name="sa-lifetime-hard", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='container', is_config=True)""",
        })

    self.__sa_lifetime_hard = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_sa_lifetime_hard(self):
    self.__sa_lifetime_hard = YANGDynClass(base=yc_sa_lifetime_hard_ietf_i2nsf_ikeless__ipsec_ikeless_sad_sad_entry_ipsec_sa_config_sa_lifetime_hard, is_container='container', yang_name="sa-lifetime-hard", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='container', is_config=True)


  def _get_sa_lifetime_soft(self):
    """
    Getter method for sa_lifetime_soft, mapped from YANG variable /ipsec_ikeless/sad/sad_entry/ipsec_sa_config/sa_lifetime_soft (container)

    YANG Description: IPsec SA soft lifetime.
    """
    return self.__sa_lifetime_soft
      
  def _set_sa_lifetime_soft(self, v, load=False):
    """
    Setter method for sa_lifetime_soft, mapped from YANG variable /ipsec_ikeless/sad/sad_entry/ipsec_sa_config/sa_lifetime_soft (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_sa_lifetime_soft is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_sa_lifetime_soft() directly.

    YANG Description: IPsec SA soft lifetime.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_sa_lifetime_soft_ietf_i2nsf_ikeless__ipsec_ikeless_sad_sad_entry_ipsec_sa_config_sa_lifetime_soft, is_container='container', yang_name="sa-lifetime-soft", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """sa_lifetime_soft must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_sa_lifetime_soft_ietf_i2nsf_ikeless__ipsec_ikeless_sad_sad_entry_ipsec_sa_config_sa_lifetime_soft, is_container='container', yang_name="sa-lifetime-soft", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='container', is_config=True)""",
        })

    self.__sa_lifetime_soft = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_sa_lifetime_soft(self):
    self.__sa_lifetime_soft = YANGDynClass(base=yc_sa_lifetime_soft_ietf_i2nsf_ikeless__ipsec_ikeless_sad_sad_entry_ipsec_sa_config_sa_lifetime_soft, is_container='container', yang_name="sa-lifetime-soft", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='container', is_config=True)


  def _get_tunnel(self):
    """
    Getter method for tunnel, mapped from YANG variable /ipsec_ikeless/sad/sad_entry/ipsec_sa_config/tunnel (container)

    YANG Description: Endpoints of the IPsec tunnel.
    """
    return self.__tunnel
      
  def _set_tunnel(self, v, load=False):
    """
    Setter method for tunnel, mapped from YANG variable /ipsec_ikeless/sad/sad_entry/ipsec_sa_config/tunnel (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_tunnel is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_tunnel() directly.

    YANG Description: Endpoints of the IPsec tunnel.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_tunnel_ietf_i2nsf_ikeless__ipsec_ikeless_sad_sad_entry_ipsec_sa_config_tunnel, is_container='container', yang_name="tunnel", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """tunnel must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_tunnel_ietf_i2nsf_ikeless__ipsec_ikeless_sad_sad_entry_ipsec_sa_config_tunnel, is_container='container', yang_name="tunnel", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='container', is_config=True)""",
        })

    self.__tunnel = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_tunnel(self):
    self.__tunnel = YANGDynClass(base=yc_tunnel_ietf_i2nsf_ikeless__ipsec_ikeless_sad_sad_entry_ipsec_sa_config_tunnel, is_container='container', yang_name="tunnel", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='container', is_config=True)


  def _get_encapsulation_type(self):
    """
    Getter method for encapsulation_type, mapped from YANG variable /ipsec_ikeless/sad/sad_entry/ipsec_sa_config/encapsulation_type (container)

    YANG Description: This container carries
configuration information about
the source and destination ports
that will be used for ESP
encapsulation of ESP packets and
the type of encapsulation when NAT
traversal is in place.
    """
    return self.__encapsulation_type
      
  def _set_encapsulation_type(self, v, load=False):
    """
    Setter method for encapsulation_type, mapped from YANG variable /ipsec_ikeless/sad/sad_entry/ipsec_sa_config/encapsulation_type (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_encapsulation_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_encapsulation_type() directly.

    YANG Description: This container carries
configuration information about
the source and destination ports
that will be used for ESP
encapsulation of ESP packets and
the type of encapsulation when NAT
traversal is in place.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_encapsulation_type_ietf_i2nsf_ikeless__ipsec_ikeless_sad_sad_entry_ipsec_sa_config_encapsulation_type, is_container='container', yang_name="encapsulation-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """encapsulation_type must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_encapsulation_type_ietf_i2nsf_ikeless__ipsec_ikeless_sad_sad_entry_ipsec_sa_config_encapsulation_type, is_container='container', yang_name="encapsulation-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='container', is_config=True)""",
        })

    self.__encapsulation_type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_encapsulation_type(self):
    self.__encapsulation_type = YANGDynClass(base=yc_encapsulation_type_ietf_i2nsf_ikeless__ipsec_ikeless_sad_sad_entry_ipsec_sa_config_encapsulation_type, is_container='container', yang_name="encapsulation-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='container', is_config=True)

  spi = __builtin__.property(_get_spi, _set_spi)
  ext_seq_num = __builtin__.property(_get_ext_seq_num, _set_ext_seq_num)
  seq_overflow = __builtin__.property(_get_seq_overflow, _set_seq_overflow)
  anti_replay_window_size = __builtin__.property(_get_anti_replay_window_size, _set_anti_replay_window_size)
  traffic_selector = __builtin__.property(_get_traffic_selector, _set_traffic_selector)
  protocol_parameters = __builtin__.property(_get_protocol_parameters, _set_protocol_parameters)
  mode = __builtin__.property(_get_mode, _set_mode)
  esp_sa = __builtin__.property(_get_esp_sa, _set_esp_sa)
  sa_lifetime_hard = __builtin__.property(_get_sa_lifetime_hard, _set_sa_lifetime_hard)
  sa_lifetime_soft = __builtin__.property(_get_sa_lifetime_soft, _set_sa_lifetime_soft)
  tunnel = __builtin__.property(_get_tunnel, _set_tunnel)
  encapsulation_type = __builtin__.property(_get_encapsulation_type, _set_encapsulation_type)


  _pyangbind_elements = OrderedDict([('spi', spi), ('ext_seq_num', ext_seq_num), ('seq_overflow', seq_overflow), ('anti_replay_window_size', anti_replay_window_size), ('traffic_selector', traffic_selector), ('protocol_parameters', protocol_parameters), ('mode', mode), ('esp_sa', esp_sa), ('sa_lifetime_hard', sa_lifetime_hard), ('sa_lifetime_soft', sa_lifetime_soft), ('tunnel', tunnel), ('encapsulation_type', encapsulation_type), ])


class yc_sa_lifetime_current_ietf_i2nsf_ikeless__ipsec_ikeless_sad_sad_entry_ipsec_sa_state_sa_lifetime_current(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-i2nsf-ikeless - based on the path /ipsec-ikeless/sad/sad-entry/ipsec-sa-state/sa-lifetime-current. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: SAD lifetime current.
  """
  __slots__ = ('_path_helper', '_extmethods', '__time','__bytes','__packets','__idle',)

  _yang_name = 'sa-lifetime-current'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(0), is_leaf=True, yang_name="time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='uint32', is_config=False)
    self.__bytes = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), default=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64)(0), is_leaf=True, yang_name="bytes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='uint64', is_config=False)
    self.__packets = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(0), is_leaf=True, yang_name="packets", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='uint32', is_config=False)
    self.__idle = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(0), is_leaf=True, yang_name="idle", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='uint32', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['ipsec-ikeless', 'sad', 'sad-entry', 'ipsec-sa-state', 'sa-lifetime-current']

  def _get_time(self):
    """
    Getter method for time, mapped from YANG variable /ipsec_ikeless/sad/sad_entry/ipsec_sa_state/sa_lifetime_current/time (uint32)

    YANG Description: Time in seconds since the IPsec SA was added.
For example, if this value is 180 seconds, it
means the IPsec SA expires in 180 seconds since
it was added.  The value 0 implies infinite.
    """
    return self.__time
      
  def _set_time(self, v, load=False):
    """
    Setter method for time, mapped from YANG variable /ipsec_ikeless/sad/sad_entry/ipsec_sa_state/sa_lifetime_current/time (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_time is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_time() directly.

    YANG Description: Time in seconds since the IPsec SA was added.
For example, if this value is 180 seconds, it
means the IPsec SA expires in 180 seconds since
it was added.  The value 0 implies infinite.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(0), is_leaf=True, yang_name="time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """time must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(0), is_leaf=True, yang_name="time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='uint32', is_config=False)""",
        })

    self.__time = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_time(self):
    self.__time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(0), is_leaf=True, yang_name="time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='uint32', is_config=False)


  def _get_bytes(self):
    """
    Getter method for bytes, mapped from YANG variable /ipsec_ikeless/sad/sad_entry/ipsec_sa_state/sa_lifetime_current/bytes (uint64)

    YANG Description: If the IPsec SA processes the number of bytes
expressed in this leaf, the IPsec SA expires and
SHOULD be rekeyed.  The value 0 implies
infinite.
    """
    return self.__bytes
      
  def _set_bytes(self, v, load=False):
    """
    Setter method for bytes, mapped from YANG variable /ipsec_ikeless/sad/sad_entry/ipsec_sa_state/sa_lifetime_current/bytes (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_bytes is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_bytes() directly.

    YANG Description: If the IPsec SA processes the number of bytes
expressed in this leaf, the IPsec SA expires and
SHOULD be rekeyed.  The value 0 implies
infinite.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), default=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64)(0), is_leaf=True, yang_name="bytes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='uint64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """bytes must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), default=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64)(0), is_leaf=True, yang_name="bytes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='uint64', is_config=False)""",
        })

    self.__bytes = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_bytes(self):
    self.__bytes = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), default=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64)(0), is_leaf=True, yang_name="bytes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='uint64', is_config=False)


  def _get_packets(self):
    """
    Getter method for packets, mapped from YANG variable /ipsec_ikeless/sad/sad_entry/ipsec_sa_state/sa_lifetime_current/packets (uint32)

    YANG Description: If the IPsec SA processes the number of packets
expressed in this leaf, the IPsec SA expires and
SHOULD be rekeyed.  The value 0 implies
infinite.
    """
    return self.__packets
      
  def _set_packets(self, v, load=False):
    """
    Setter method for packets, mapped from YANG variable /ipsec_ikeless/sad/sad_entry/ipsec_sa_state/sa_lifetime_current/packets (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_packets is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_packets() directly.

    YANG Description: If the IPsec SA processes the number of packets
expressed in this leaf, the IPsec SA expires and
SHOULD be rekeyed.  The value 0 implies
infinite.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(0), is_leaf=True, yang_name="packets", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """packets must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(0), is_leaf=True, yang_name="packets", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='uint32', is_config=False)""",
        })

    self.__packets = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_packets(self):
    self.__packets = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(0), is_leaf=True, yang_name="packets", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='uint32', is_config=False)


  def _get_idle(self):
    """
    Getter method for idle, mapped from YANG variable /ipsec_ikeless/sad/sad_entry/ipsec_sa_state/sa_lifetime_current/idle (uint32)

    YANG Description: When an NSF stores an IPsec SA, it
consumes system resources.  For an idle IPsec SA, this
is a waste of resources.  If the IPsec SA is idle
during this number of seconds, the IPsec SA
SHOULD be removed.  The value 0 implies
infinite.
    """
    return self.__idle
      
  def _set_idle(self, v, load=False):
    """
    Setter method for idle, mapped from YANG variable /ipsec_ikeless/sad/sad_entry/ipsec_sa_state/sa_lifetime_current/idle (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_idle is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_idle() directly.

    YANG Description: When an NSF stores an IPsec SA, it
consumes system resources.  For an idle IPsec SA, this
is a waste of resources.  If the IPsec SA is idle
during this number of seconds, the IPsec SA
SHOULD be removed.  The value 0 implies
infinite.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(0), is_leaf=True, yang_name="idle", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """idle must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(0), is_leaf=True, yang_name="idle", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='uint32', is_config=False)""",
        })

    self.__idle = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_idle(self):
    self.__idle = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(0), is_leaf=True, yang_name="idle", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='uint32', is_config=False)

  time = __builtin__.property(_get_time)
  bytes = __builtin__.property(_get_bytes)
  packets = __builtin__.property(_get_packets)
  idle = __builtin__.property(_get_idle)


  _pyangbind_elements = OrderedDict([('time', time), ('bytes', bytes), ('packets', packets), ('idle', idle), ])


class yc_replay_window_ietf_i2nsf_ikeless__ipsec_ikeless_sad_sad_entry_ipsec_sa_state_replay_stats_replay_window(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-i2nsf-ikeless - based on the path /ipsec-ikeless/sad/sad-entry/ipsec-sa-state/replay-stats/replay-window. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This container contains three
parameters that define the state
of the replay window: window size (w),
highest sequence number authenticated (t),
and lower bound of the window (b), according
to Appendix A2.1 in RFC 4303 (w = t - b + 1).
  """
  __slots__ = ('_path_helper', '_extmethods', '__w','__t','__b',)

  _yang_name = 'replay-window'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__w = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="w", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='uint32', is_config=False)
    self.__t = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="t", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='uint64', is_config=False)
    self.__b = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="b", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='uint64', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['ipsec-ikeless', 'sad', 'sad-entry', 'ipsec-sa-state', 'replay-stats', 'replay-window']

  def _get_w(self):
    """
    Getter method for w, mapped from YANG variable /ipsec_ikeless/sad/sad_entry/ipsec_sa_state/replay_stats/replay_window/w (uint32)

    YANG Description: Size of the replay window.
    """
    return self.__w
      
  def _set_w(self, v, load=False):
    """
    Setter method for w, mapped from YANG variable /ipsec_ikeless/sad/sad_entry/ipsec_sa_state/replay_stats/replay_window/w (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_w is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_w() directly.

    YANG Description: Size of the replay window.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="w", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """w must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="w", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='uint32', is_config=False)""",
        })

    self.__w = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_w(self):
    self.__w = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="w", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='uint32', is_config=False)


  def _get_t(self):
    """
    Getter method for t, mapped from YANG variable /ipsec_ikeless/sad/sad_entry/ipsec_sa_state/replay_stats/replay_window/t (uint64)

    YANG Description: Highest sequence number
authenticated so far,
upper bound of window.
    """
    return self.__t
      
  def _set_t(self, v, load=False):
    """
    Setter method for t, mapped from YANG variable /ipsec_ikeless/sad/sad_entry/ipsec_sa_state/replay_stats/replay_window/t (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_t is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_t() directly.

    YANG Description: Highest sequence number
authenticated so far,
upper bound of window.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="t", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='uint64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """t must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="t", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='uint64', is_config=False)""",
        })

    self.__t = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_t(self):
    self.__t = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="t", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='uint64', is_config=False)


  def _get_b(self):
    """
    Getter method for b, mapped from YANG variable /ipsec_ikeless/sad/sad_entry/ipsec_sa_state/replay_stats/replay_window/b (uint64)

    YANG Description: Lower bound of window.
    """
    return self.__b
      
  def _set_b(self, v, load=False):
    """
    Setter method for b, mapped from YANG variable /ipsec_ikeless/sad/sad_entry/ipsec_sa_state/replay_stats/replay_window/b (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_b is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_b() directly.

    YANG Description: Lower bound of window.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="b", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='uint64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """b must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="b", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='uint64', is_config=False)""",
        })

    self.__b = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_b(self):
    self.__b = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="b", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='uint64', is_config=False)

  w = __builtin__.property(_get_w)
  t = __builtin__.property(_get_t)
  b = __builtin__.property(_get_b)


  _pyangbind_elements = OrderedDict([('w', w), ('t', t), ('b', b), ])


class yc_replay_stats_ietf_i2nsf_ikeless__ipsec_ikeless_sad_sad_entry_ipsec_sa_state_replay_stats(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-i2nsf-ikeless - based on the path /ipsec-ikeless/sad/sad-entry/ipsec-sa-state/replay-stats. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: State data about the anti-replay
window.
  """
  __slots__ = ('_path_helper', '_extmethods', '__replay_window','__packet_dropped','__failed','__seq_number_counter',)

  _yang_name = 'replay-stats'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__replay_window = YANGDynClass(base=yc_replay_window_ietf_i2nsf_ikeless__ipsec_ikeless_sad_sad_entry_ipsec_sa_state_replay_stats_replay_window, is_container='container', yang_name="replay-window", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='container', is_config=False)
    self.__packet_dropped = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="packet-dropped", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='yang:counter64', is_config=False)
    self.__failed = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="failed", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='yang:counter64', is_config=False)
    self.__seq_number_counter = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="seq-number-counter", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='uint64', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['ipsec-ikeless', 'sad', 'sad-entry', 'ipsec-sa-state', 'replay-stats']

  def _get_replay_window(self):
    """
    Getter method for replay_window, mapped from YANG variable /ipsec_ikeless/sad/sad_entry/ipsec_sa_state/replay_stats/replay_window (container)

    YANG Description: This container contains three
parameters that define the state
of the replay window: window size (w),
highest sequence number authenticated (t),
and lower bound of the window (b), according
to Appendix A2.1 in RFC 4303 (w = t - b + 1).
    """
    return self.__replay_window
      
  def _set_replay_window(self, v, load=False):
    """
    Setter method for replay_window, mapped from YANG variable /ipsec_ikeless/sad/sad_entry/ipsec_sa_state/replay_stats/replay_window (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_replay_window is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_replay_window() directly.

    YANG Description: This container contains three
parameters that define the state
of the replay window: window size (w),
highest sequence number authenticated (t),
and lower bound of the window (b), according
to Appendix A2.1 in RFC 4303 (w = t - b + 1).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_replay_window_ietf_i2nsf_ikeless__ipsec_ikeless_sad_sad_entry_ipsec_sa_state_replay_stats_replay_window, is_container='container', yang_name="replay-window", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """replay_window must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_replay_window_ietf_i2nsf_ikeless__ipsec_ikeless_sad_sad_entry_ipsec_sa_state_replay_stats_replay_window, is_container='container', yang_name="replay-window", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='container', is_config=False)""",
        })

    self.__replay_window = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_replay_window(self):
    self.__replay_window = YANGDynClass(base=yc_replay_window_ietf_i2nsf_ikeless__ipsec_ikeless_sad_sad_entry_ipsec_sa_state_replay_stats_replay_window, is_container='container', yang_name="replay-window", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='container', is_config=False)


  def _get_packet_dropped(self):
    """
    Getter method for packet_dropped, mapped from YANG variable /ipsec_ikeless/sad/sad_entry/ipsec_sa_state/replay_stats/packet_dropped (yang:counter64)

    YANG Description: Packets dropped
because they are
replay packets.
    """
    return self.__packet_dropped
      
  def _set_packet_dropped(self, v, load=False):
    """
    Setter method for packet_dropped, mapped from YANG variable /ipsec_ikeless/sad/sad_entry/ipsec_sa_state/replay_stats/packet_dropped (yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_packet_dropped is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_packet_dropped() directly.

    YANG Description: Packets dropped
because they are
replay packets.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="packet-dropped", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """packet_dropped must be of a type compatible with yang:counter64""",
          'defined-type': "yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="packet-dropped", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='yang:counter64', is_config=False)""",
        })

    self.__packet_dropped = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_packet_dropped(self):
    self.__packet_dropped = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="packet-dropped", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='yang:counter64', is_config=False)


  def _get_failed(self):
    """
    Getter method for failed, mapped from YANG variable /ipsec_ikeless/sad/sad_entry/ipsec_sa_state/replay_stats/failed (yang:counter64)

    YANG Description: Number of packets detected out
of the replay window.
    """
    return self.__failed
      
  def _set_failed(self, v, load=False):
    """
    Setter method for failed, mapped from YANG variable /ipsec_ikeless/sad/sad_entry/ipsec_sa_state/replay_stats/failed (yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_failed is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_failed() directly.

    YANG Description: Number of packets detected out
of the replay window.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="failed", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """failed must be of a type compatible with yang:counter64""",
          'defined-type': "yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="failed", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='yang:counter64', is_config=False)""",
        })

    self.__failed = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_failed(self):
    self.__failed = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="failed", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='yang:counter64', is_config=False)


  def _get_seq_number_counter(self):
    """
    Getter method for seq_number_counter, mapped from YANG variable /ipsec_ikeless/sad/sad_entry/ipsec_sa_state/replay_stats/seq_number_counter (uint64)

    YANG Description: A 64-bit counter when this
IPsec SA is using Extended
Sequence Number or 32-bit
counter when it is not.
Current value of sequence
number.
    """
    return self.__seq_number_counter
      
  def _set_seq_number_counter(self, v, load=False):
    """
    Setter method for seq_number_counter, mapped from YANG variable /ipsec_ikeless/sad/sad_entry/ipsec_sa_state/replay_stats/seq_number_counter (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_seq_number_counter is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_seq_number_counter() directly.

    YANG Description: A 64-bit counter when this
IPsec SA is using Extended
Sequence Number or 32-bit
counter when it is not.
Current value of sequence
number.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="seq-number-counter", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='uint64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """seq_number_counter must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="seq-number-counter", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='uint64', is_config=False)""",
        })

    self.__seq_number_counter = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_seq_number_counter(self):
    self.__seq_number_counter = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="seq-number-counter", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='uint64', is_config=False)

  replay_window = __builtin__.property(_get_replay_window)
  packet_dropped = __builtin__.property(_get_packet_dropped)
  failed = __builtin__.property(_get_failed)
  seq_number_counter = __builtin__.property(_get_seq_number_counter)


  _pyangbind_elements = OrderedDict([('replay_window', replay_window), ('packet_dropped', packet_dropped), ('failed', failed), ('seq_number_counter', seq_number_counter), ])


class yc_ipsec_sa_state_ietf_i2nsf_ikeless__ipsec_ikeless_sad_sad_entry_ipsec_sa_state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-i2nsf-ikeless - based on the path /ipsec-ikeless/sad/sad-entry/ipsec-sa-state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Container describing IPsec SA state
data.
  """
  __slots__ = ('_path_helper', '_extmethods', '__sa_lifetime_current','__replay_stats',)

  _yang_name = 'ipsec-sa-state'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__sa_lifetime_current = YANGDynClass(base=yc_sa_lifetime_current_ietf_i2nsf_ikeless__ipsec_ikeless_sad_sad_entry_ipsec_sa_state_sa_lifetime_current, is_container='container', yang_name="sa-lifetime-current", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='container', is_config=False)
    self.__replay_stats = YANGDynClass(base=yc_replay_stats_ietf_i2nsf_ikeless__ipsec_ikeless_sad_sad_entry_ipsec_sa_state_replay_stats, is_container='container', yang_name="replay-stats", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='container', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['ipsec-ikeless', 'sad', 'sad-entry', 'ipsec-sa-state']

  def _get_sa_lifetime_current(self):
    """
    Getter method for sa_lifetime_current, mapped from YANG variable /ipsec_ikeless/sad/sad_entry/ipsec_sa_state/sa_lifetime_current (container)

    YANG Description: SAD lifetime current.
    """
    return self.__sa_lifetime_current
      
  def _set_sa_lifetime_current(self, v, load=False):
    """
    Setter method for sa_lifetime_current, mapped from YANG variable /ipsec_ikeless/sad/sad_entry/ipsec_sa_state/sa_lifetime_current (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_sa_lifetime_current is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_sa_lifetime_current() directly.

    YANG Description: SAD lifetime current.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_sa_lifetime_current_ietf_i2nsf_ikeless__ipsec_ikeless_sad_sad_entry_ipsec_sa_state_sa_lifetime_current, is_container='container', yang_name="sa-lifetime-current", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """sa_lifetime_current must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_sa_lifetime_current_ietf_i2nsf_ikeless__ipsec_ikeless_sad_sad_entry_ipsec_sa_state_sa_lifetime_current, is_container='container', yang_name="sa-lifetime-current", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='container', is_config=False)""",
        })

    self.__sa_lifetime_current = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_sa_lifetime_current(self):
    self.__sa_lifetime_current = YANGDynClass(base=yc_sa_lifetime_current_ietf_i2nsf_ikeless__ipsec_ikeless_sad_sad_entry_ipsec_sa_state_sa_lifetime_current, is_container='container', yang_name="sa-lifetime-current", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='container', is_config=False)


  def _get_replay_stats(self):
    """
    Getter method for replay_stats, mapped from YANG variable /ipsec_ikeless/sad/sad_entry/ipsec_sa_state/replay_stats (container)

    YANG Description: State data about the anti-replay
window.
    """
    return self.__replay_stats
      
  def _set_replay_stats(self, v, load=False):
    """
    Setter method for replay_stats, mapped from YANG variable /ipsec_ikeless/sad/sad_entry/ipsec_sa_state/replay_stats (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_replay_stats is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_replay_stats() directly.

    YANG Description: State data about the anti-replay
window.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_replay_stats_ietf_i2nsf_ikeless__ipsec_ikeless_sad_sad_entry_ipsec_sa_state_replay_stats, is_container='container', yang_name="replay-stats", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """replay_stats must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_replay_stats_ietf_i2nsf_ikeless__ipsec_ikeless_sad_sad_entry_ipsec_sa_state_replay_stats, is_container='container', yang_name="replay-stats", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='container', is_config=False)""",
        })

    self.__replay_stats = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_replay_stats(self):
    self.__replay_stats = YANGDynClass(base=yc_replay_stats_ietf_i2nsf_ikeless__ipsec_ikeless_sad_sad_entry_ipsec_sa_state_replay_stats, is_container='container', yang_name="replay-stats", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='container', is_config=False)

  sa_lifetime_current = __builtin__.property(_get_sa_lifetime_current)
  replay_stats = __builtin__.property(_get_replay_stats)


  _pyangbind_elements = OrderedDict([('sa_lifetime_current', sa_lifetime_current), ('replay_stats', replay_stats), ])


class yc_sad_entry_ietf_i2nsf_ikeless__ipsec_ikeless_sad_sad_entry(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-i2nsf-ikeless - based on the path /ipsec-ikeless/sad/sad-entry. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of SAD entries that form the SAD.
  """
  __slots__ = ('_path_helper', '_extmethods', '__name','__reqid','__ipsec_sa_config','__ipsec_sa_state',)

  _yang_name = 'sad-entry'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='string', is_config=True)
    self.__reqid = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), default=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64)(0), is_leaf=True, yang_name="reqid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='uint64', is_config=True)
    self.__ipsec_sa_config = YANGDynClass(base=yc_ipsec_sa_config_ietf_i2nsf_ikeless__ipsec_ikeless_sad_sad_entry_ipsec_sa_config, is_container='container', yang_name="ipsec-sa-config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='container', is_config=True)
    self.__ipsec_sa_state = YANGDynClass(base=yc_ipsec_sa_state_ietf_i2nsf_ikeless__ipsec_ikeless_sad_sad_entry_ipsec_sa_state, is_container='container', yang_name="ipsec-sa-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['ipsec-ikeless', 'sad', 'sad-entry']

  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /ipsec_ikeless/sad/sad_entry/name (string)

    YANG Description: SAD-entry-unique name to identify this
entry.
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /ipsec_ikeless/sad/sad_entry/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: SAD-entry-unique name to identify this
entry.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='string', is_config=True)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='string', is_config=True)


  def _get_reqid(self):
    """
    Getter method for reqid, mapped from YANG variable /ipsec_ikeless/sad/sad_entry/reqid (uint64)

    YANG Description: This value allows linking this
IPsec SA with an IPsec policy with
the same reqid.
    """
    return self.__reqid
      
  def _set_reqid(self, v, load=False):
    """
    Setter method for reqid, mapped from YANG variable /ipsec_ikeless/sad/sad_entry/reqid (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_reqid is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_reqid() directly.

    YANG Description: This value allows linking this
IPsec SA with an IPsec policy with
the same reqid.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), default=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64)(0), is_leaf=True, yang_name="reqid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='uint64', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """reqid must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), default=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64)(0), is_leaf=True, yang_name="reqid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='uint64', is_config=True)""",
        })

    self.__reqid = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_reqid(self):
    self.__reqid = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), default=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64)(0), is_leaf=True, yang_name="reqid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='uint64', is_config=True)


  def _get_ipsec_sa_config(self):
    """
    Getter method for ipsec_sa_config, mapped from YANG variable /ipsec_ikeless/sad/sad_entry/ipsec_sa_config (container)

    YANG Description: This container allows configuring
details of an IPsec SA.
    """
    return self.__ipsec_sa_config
      
  def _set_ipsec_sa_config(self, v, load=False):
    """
    Setter method for ipsec_sa_config, mapped from YANG variable /ipsec_ikeless/sad/sad_entry/ipsec_sa_config (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ipsec_sa_config is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ipsec_sa_config() directly.

    YANG Description: This container allows configuring
details of an IPsec SA.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_ipsec_sa_config_ietf_i2nsf_ikeless__ipsec_ikeless_sad_sad_entry_ipsec_sa_config, is_container='container', yang_name="ipsec-sa-config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ipsec_sa_config must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_ipsec_sa_config_ietf_i2nsf_ikeless__ipsec_ikeless_sad_sad_entry_ipsec_sa_config, is_container='container', yang_name="ipsec-sa-config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='container', is_config=True)""",
        })

    self.__ipsec_sa_config = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ipsec_sa_config(self):
    self.__ipsec_sa_config = YANGDynClass(base=yc_ipsec_sa_config_ietf_i2nsf_ikeless__ipsec_ikeless_sad_sad_entry_ipsec_sa_config, is_container='container', yang_name="ipsec-sa-config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='container', is_config=True)


  def _get_ipsec_sa_state(self):
    """
    Getter method for ipsec_sa_state, mapped from YANG variable /ipsec_ikeless/sad/sad_entry/ipsec_sa_state (container)

    YANG Description: Container describing IPsec SA state
data.
    """
    return self.__ipsec_sa_state
      
  def _set_ipsec_sa_state(self, v, load=False):
    """
    Setter method for ipsec_sa_state, mapped from YANG variable /ipsec_ikeless/sad/sad_entry/ipsec_sa_state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ipsec_sa_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ipsec_sa_state() directly.

    YANG Description: Container describing IPsec SA state
data.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_ipsec_sa_state_ietf_i2nsf_ikeless__ipsec_ikeless_sad_sad_entry_ipsec_sa_state, is_container='container', yang_name="ipsec-sa-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ipsec_sa_state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_ipsec_sa_state_ietf_i2nsf_ikeless__ipsec_ikeless_sad_sad_entry_ipsec_sa_state, is_container='container', yang_name="ipsec-sa-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='container', is_config=True)""",
        })

    self.__ipsec_sa_state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ipsec_sa_state(self):
    self.__ipsec_sa_state = YANGDynClass(base=yc_ipsec_sa_state_ietf_i2nsf_ikeless__ipsec_ikeless_sad_sad_entry_ipsec_sa_state, is_container='container', yang_name="ipsec-sa-state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='container', is_config=True)

  name = __builtin__.property(_get_name, _set_name)
  reqid = __builtin__.property(_get_reqid, _set_reqid)
  ipsec_sa_config = __builtin__.property(_get_ipsec_sa_config, _set_ipsec_sa_config)
  ipsec_sa_state = __builtin__.property(_get_ipsec_sa_state, _set_ipsec_sa_state)


  _pyangbind_elements = OrderedDict([('name', name), ('reqid', reqid), ('ipsec_sa_config', ipsec_sa_config), ('ipsec_sa_state', ipsec_sa_state), ])


class yc_sad_ietf_i2nsf_ikeless__ipsec_ikeless_sad(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-i2nsf-ikeless - based on the path /ipsec-ikeless/sad. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configuration of the IPsec Security Association
Database (SAD).
  """
  __slots__ = ('_path_helper', '_extmethods', '__sad_entry',)

  _yang_name = 'sad'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__sad_entry = YANGDynClass(base=YANGListType("name",yc_sad_entry_ietf_i2nsf_ikeless__ipsec_ikeless_sad_sad_entry, yang_name="sad-entry", parent=self, is_container='list', user_ordered=True, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="sad-entry", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['ipsec-ikeless', 'sad']

  def _get_sad_entry(self):
    """
    Getter method for sad_entry, mapped from YANG variable /ipsec_ikeless/sad/sad_entry (list)

    YANG Description: List of SAD entries that form the SAD.
    """
    return self.__sad_entry
      
  def _set_sad_entry(self, v, load=False):
    """
    Setter method for sad_entry, mapped from YANG variable /ipsec_ikeless/sad/sad_entry (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_sad_entry is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_sad_entry() directly.

    YANG Description: List of SAD entries that form the SAD.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("name",yc_sad_entry_ietf_i2nsf_ikeless__ipsec_ikeless_sad_sad_entry, yang_name="sad-entry", parent=self, is_container='list', user_ordered=True, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="sad-entry", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """sad_entry must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("name",yc_sad_entry_ietf_i2nsf_ikeless__ipsec_ikeless_sad_sad_entry, yang_name="sad-entry", parent=self, is_container='list', user_ordered=True, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="sad-entry", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='list', is_config=True)""",
        })

    self.__sad_entry = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_sad_entry(self):
    self.__sad_entry = YANGDynClass(base=YANGListType("name",yc_sad_entry_ietf_i2nsf_ikeless__ipsec_ikeless_sad_sad_entry, yang_name="sad-entry", parent=self, is_container='list', user_ordered=True, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="sad-entry", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='list', is_config=True)

  sad_entry = __builtin__.property(_get_sad_entry, _set_sad_entry)


  _pyangbind_elements = OrderedDict([('sad_entry', sad_entry), ])


class yc_ipsec_ikeless_ietf_i2nsf_ikeless__ipsec_ikeless(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-i2nsf-ikeless - based on the path /ipsec-ikeless. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Container for configuration of the IKE-less
case. The container contains two additional
containers: 'spd' and 'sad'.  The first allows the
I2NSF Controller to configure IPsec policies in
the Security Policy Database (SPD), and the second
allows the I2NSF Controller to configure IPsec
Security Associations (IPsec SAs) in the Security
Association Database (SAD).
  """
  __slots__ = ('_path_helper', '_extmethods', '__spd','__sad',)

  _yang_name = 'ipsec-ikeless'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__spd = YANGDynClass(base=yc_spd_ietf_i2nsf_ikeless__ipsec_ikeless_spd, is_container='container', yang_name="spd", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='container', is_config=True)
    self.__sad = YANGDynClass(base=yc_sad_ietf_i2nsf_ikeless__ipsec_ikeless_sad, is_container='container', yang_name="sad", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['ipsec-ikeless']

  def _get_spd(self):
    """
    Getter method for spd, mapped from YANG variable /ipsec_ikeless/spd (container)

    YANG Description: Configuration of the Security Policy Database
(SPD).
    """
    return self.__spd
      
  def _set_spd(self, v, load=False):
    """
    Setter method for spd, mapped from YANG variable /ipsec_ikeless/spd (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_spd is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_spd() directly.

    YANG Description: Configuration of the Security Policy Database
(SPD).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_spd_ietf_i2nsf_ikeless__ipsec_ikeless_spd, is_container='container', yang_name="spd", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """spd must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_spd_ietf_i2nsf_ikeless__ipsec_ikeless_spd, is_container='container', yang_name="spd", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='container', is_config=True)""",
        })

    self.__spd = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_spd(self):
    self.__spd = YANGDynClass(base=yc_spd_ietf_i2nsf_ikeless__ipsec_ikeless_spd, is_container='container', yang_name="spd", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='container', is_config=True)


  def _get_sad(self):
    """
    Getter method for sad, mapped from YANG variable /ipsec_ikeless/sad (container)

    YANG Description: Configuration of the IPsec Security Association
Database (SAD).
    """
    return self.__sad
      
  def _set_sad(self, v, load=False):
    """
    Setter method for sad, mapped from YANG variable /ipsec_ikeless/sad (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_sad is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_sad() directly.

    YANG Description: Configuration of the IPsec Security Association
Database (SAD).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_sad_ietf_i2nsf_ikeless__ipsec_ikeless_sad, is_container='container', yang_name="sad", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """sad must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_sad_ietf_i2nsf_ikeless__ipsec_ikeless_sad, is_container='container', yang_name="sad", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='container', is_config=True)""",
        })

    self.__sad = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_sad(self):
    self.__sad = YANGDynClass(base=yc_sad_ietf_i2nsf_ikeless__ipsec_ikeless_sad, is_container='container', yang_name="sad", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='container', is_config=True)

  spd = __builtin__.property(_get_spd, _set_spd)
  sad = __builtin__.property(_get_sad, _set_sad)


  _pyangbind_elements = OrderedDict([('spd', spd), ('sad', sad), ])


class ietf_i2nsf_ikeless(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-i2nsf-ikeless - based on the path /ietf-i2nsf-ikeless. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Data model for IKE-less case in the SDN-based IPsec flow
protection service.

The key words 'MUST', 'MUST NOT', 'REQUIRED', 'SHALL',
'SHALL NOT', 'SHOULD', 'SHOULD NOT', 'RECOMMENDED',
'NOT RECOMMENDED', 'MAY', and 'OPTIONAL' in this
document are to be interpreted as described in BCP 14
(RFC 2119) (RFC 8174) when, and only when, they appear
in all capitals, as shown here.

Copyright (c) 2021 IETF Trust and the persons
identified as authors of the code.  All rights reserved.

Redistribution and use in source and binary forms, with or
without modification, is permitted pursuant to, and subject
to the license terms contained in, the Simplified BSD License
set forth in Section 4.c of the IETF Trust's Legal Provisions
Relating to IETF Documents
(https://trustee.ietf.org/license-info).

This version of this YANG module is part of RFC 9061; see
the RFC itself for full legal notices.
  """
  __slots__ = ('_path_helper', '_extmethods', '__ipsec_ikeless',)

  _yang_name = 'ietf-i2nsf-ikeless'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__ipsec_ikeless = YANGDynClass(base=yc_ipsec_ikeless_ietf_i2nsf_ikeless__ipsec_ikeless, is_container='container', yang_name="ipsec-ikeless", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _get_ipsec_ikeless(self):
    """
    Getter method for ipsec_ikeless, mapped from YANG variable /ipsec_ikeless (container)

    YANG Description: Container for configuration of the IKE-less
case. The container contains two additional
containers: 'spd' and 'sad'.  The first allows the
I2NSF Controller to configure IPsec policies in
the Security Policy Database (SPD), and the second
allows the I2NSF Controller to configure IPsec
Security Associations (IPsec SAs) in the Security
Association Database (SAD).
    """
    return self.__ipsec_ikeless
      
  def _set_ipsec_ikeless(self, v, load=False):
    """
    Setter method for ipsec_ikeless, mapped from YANG variable /ipsec_ikeless (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ipsec_ikeless is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ipsec_ikeless() directly.

    YANG Description: Container for configuration of the IKE-less
case. The container contains two additional
containers: 'spd' and 'sad'.  The first allows the
I2NSF Controller to configure IPsec policies in
the Security Policy Database (SPD), and the second
allows the I2NSF Controller to configure IPsec
Security Associations (IPsec SAs) in the Security
Association Database (SAD).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_ipsec_ikeless_ietf_i2nsf_ikeless__ipsec_ikeless, is_container='container', yang_name="ipsec-ikeless", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ipsec_ikeless must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_ipsec_ikeless_ietf_i2nsf_ikeless__ipsec_ikeless, is_container='container', yang_name="ipsec-ikeless", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='container', is_config=True)""",
        })

    self.__ipsec_ikeless = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ipsec_ikeless(self):
    self.__ipsec_ikeless = YANGDynClass(base=yc_ipsec_ikeless_ietf_i2nsf_ikeless__ipsec_ikeless, is_container='container', yang_name="ipsec-ikeless", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-i2nsf-ikeless', defining_module='ietf-i2nsf-ikeless', yang_type='container', is_config=True)

  ipsec_ikeless = __builtin__.property(_get_ipsec_ikeless, _set_ipsec_ikeless)


  _pyangbind_elements = OrderedDict([('ipsec_ikeless', ipsec_ikeless), ])


